---
title: Visual Studio 的应用程序模式 |Microsoft Docs
description: 了解文档窗口、工具窗口和无模式对话框之间的差异，包括 Visual Studio 的新功能的窗口使用模式。
ms.custom: SEO-VS-2020
ms.date: 04/26/2017
ms.topic: reference
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
author: leslierichardson95
ms.author: lerich
manager: jmartens
ms.technology: vs-ide-sdk
ms.workload:
- vssdk
ms.openlocfilehash: fe65ecd124f8c76bf10fb9e9c1f157b50af5b0ce
ms.sourcegitcommit: 68897da7d74c31ae1ebf5d47c7b5ddc9b108265b
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/13/2021
ms.locfileid: "122069606"
---
# <a name="application-patterns-for-visual-studio"></a>Visual Studio 的应用程序模式
## <a name="window-interactions"></a><a name="BKMK_WindowInteractions"></a> 窗口交互

### <a name="overview"></a>概述
Visual Studio 中使用的两种主要窗口类型是文档编辑器和工具窗口。 很少但可能是大的无模式对话框。 尽管这些在 shell 中都是无模式的，但是它们的模式在本质上是不同的。 本部分介绍文档窗口、工具窗口和无模式对话框之间的差异。 [对话框中介绍](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)了模式对话框模式。

### <a name="comparing-window-usage-patterns"></a>比较窗口使用模式
**文档窗口** 几乎始终显示在文档中。 这为文档编辑器提供了一个 "中心阶段"，用于排列补充工具窗口。

**工具窗口** 最常显示为相对 IDE 边缘折叠的单独的小窗口。 这可以是可见、隐藏或自动隐藏。 但是，在文档中，有时会通过取消选中窗口中的 " **窗口"/"停靠** " 属性来显示工具窗口。 这会产生更多真实的内容，但也是一种常见的设计决策：尝试集成到 Visual Studio 时，必须确定功能是否应显示工具窗口或文档窗口。

不建议在 Visual Studio 中进行 **无模式对话框**。 大多数无模式对话框按定义、浮动工具窗口，应以这种方式实现。 如果固定到 shell 一侧的正常工具窗口的大小过大限制，则允许无模式对话框。 在用户可能会将对话框移至辅助监视器的情况下，也可以使用它们。

仔细考虑所需的容器类型。 下表中提供了 UI 设计的常见使用模式注意事项。

||文档窗口|工具窗口|无模式对话框|
|-|---------------------|-----------------|---------------------|
| **位置** | 始终定位在文档中，并且不会停靠在 IDE 的边缘周围。 它可以 "拔出"，使其独立于主外壳。 | 通常，tab 在 IDE 的边缘周围停靠，但可以自定义为浮动、自动隐藏 (取消固定) 或在文档中停靠。|与 IDE 分离的大型浮动窗口。 |
| **提交模型** | *延迟提交*<br /><br /> 若要将数据保存在文档中，用户必须发出 **文件 " &gt; 保存**"、" **另存为**" 或 " **全部保存** " 命令。 文档窗口的概念是 "更新"，然后将其提交到其中一个 "保存" 命令。 关闭文档窗口时，所有内容都将保存到磁盘或丢失。 | *立即提交*<br /><br /> 无保存模式。 对于帮助编辑文件的检查器工具窗口，该文件必须在活动编辑器或设计器中打开，并且编辑器或设计器拥有保存。 | *延迟或立即提交*<br /><br /> 大多数情况下，大型无模式对话框都需要一个操作来提交更改，并允许执行 "取消" 操作，从而回滚在对话会话中所做的任何更改。  这将从该工具窗口中的工具窗口中区分无模式对话框，窗口始终具有即时提交模型。 |
| **可见性** | *打开/创建 (文件) 并关闭*<br /><br /> 打开文档窗口是通过打开现有文档或使用模板创建新文档来完成的。 没有 "打开 \<specific editor> " 命令。 | *隐藏和显示*<br /><br /> 可以隐藏或显示单实例工具窗口。 无论是在视图中还是在隐藏状态，工具窗口中的内容和状态都将保留。 多实例工具窗口可以关闭并隐藏。 当关闭多实例工具窗口时，将放弃工具窗口中的内容和状态。 | *从命令启动*<br /><br /> 从基于任务的命令启动对话框。 |
| **实例** | *多实例*<br /><br /> 可以同时打开多个编辑器和编辑不同的文件，而某些编辑器还允许在多个编辑器中打开相同的文件 (使用 " **&gt; 新建窗口** " 命令) 。<br /><br /> 单个编辑器可以同时编辑一个或多个文件 (Project 设计器) 。 | *单实例或多实例*<br /><br /> 内容将更改以反映上下文 (如属性浏览器中所示) 或将焦点/上下文推送到其他 windows (任务列表解决方案资源管理器) 。<br /><br /> 单实例工具窗口和多实例工具窗口都应与活动文档窗口相关联，除非有很有说服力的原因不是。 | *单实例* |
| **示例** | **文本编辑器**，如代码编辑器<br /><br /> **设计图** 面，如窗体设计器或建模图面<br /><br /> **类似于对话框的控件布局**，如清单设计器 | **解决方案资源管理器** 提供解决方案和解决方案中包含的项目<br /><br /> **服务器资源管理器** 提供用户选择在窗口中打开的服务器和数据连接的层次结构视图。 从数据库层次结构（如查询）打开对象会打开文档窗口，并允许用户编辑查询。<br /><br /> **属性浏览器** 显示在文档窗口或其他工具窗口中选择的对象的属性。 属性在分层网格视图或类似于对话框的复杂控件中提供，并允许用户设置这些属性的值。 | |

## <a name="tool-windows"></a><a name="BKMK_ToolWindows"></a> 工具窗口

### <a name="overview"></a>概述
工具窗口支持在文档窗口中发生的用户工作。 它们可用于显示一个层次结构，该层次结构表示 Visual Studio 提供并可以操作的基础根对象。

考虑在 IDE 中使用新工具窗口时，作者应：

- 使用与任务相对应的现有工具窗口，而不是创建具有类似功能的新工具窗口。 仅当新工具窗口提供了明显不同的 "工具" 或功能，而该工具不能集成到类似的窗口中，或通过将现有窗口转换为透视中心时，才应创建新工具窗口。

- 如果需要，请使用 "工具" 窗口顶部的标准命令栏。

- 与其他工具窗口中已存在的用于控件演示和键盘导航的模式保持一致。

- 与其他工具窗口中的控件表示形式一致。

- 使特定于文档的工具窗口尽可能自动可见，以便仅当激活父文档时才显示这些工具。

- 确保其窗口内容可通过键盘导航 (支持箭头键) 。

#### <a name="tool-window-states"></a>工具窗口状态
Visual Studio 工具窗口具有不同的状态，其中某些状态是用户激活的 (例如自动隐藏功能) 。 其他状态（如 "自动可见"）允许工具窗口出现在正确的上下文中，并在不需要时隐藏。 总共有五个工具窗口状态。

- **停靠/固定** 的工具窗口可以附加到文档区域的四个边。 图钉图标将显示在工具窗口的标题栏中。 工具窗口可以沿 shell 和其他工具窗口的边缘水平或垂直停靠，还可以与选项卡链接在一起。

- **自动隐藏** 的工具窗口已取消固定。 该窗口可以弹出，使选项卡 (的工具窗口的名称，并且其图标) 文档区域的边缘上。 当用户将鼠标指针悬停在选项卡上时，工具窗口将会滑出。

- 当另一段 UI （如编辑器）启动或获得焦点时 **，自动显示的工具窗口** 将自动显示。

- **浮动** 工具窗口在 IDE 外部悬停。 这对于多监视器配置非常有用。

- **选项卡式文档** 工具窗口可停靠在文档中。 这对于大型工具窗口（如对象浏览器）非常有用，它需要更多的房地产，而不是停靠到框架边缘。

![Visual Studio 中的“工具”窗口状态](../../extensibility/ux-guidelines/media/0702-01_toolwindowstates.png "0702-01_ToolWindowStates")<br />Visual Studio 中的“工具”窗口状态

#### <a name="single-instance-and-multi-instance"></a>单实例和多实例
工具窗口是单实例或多实例。 某些单实例工具窗口可能与活动文档窗口相关联，而多实例工具窗口可能不会。 多实例工具窗口通过创建新的窗口实例来响应 **窗口 " &gt; 新建窗口** " 命令。 下图演示了一个工具窗口，该窗口在窗口的实例处于活动状态时启用 "新建窗口" 命令：

![在窗口的实例处于活动状态时启用 "新建窗口" 命令的工具窗口](../../extensibility/ux-guidelines/media/0702-02_toolwindowenablingcommand.png "0702-02_ToolWindowEnablingCommand")<br />在窗口的实例处于活动状态时启用 "新建窗口" 命令的工具窗口

可以隐藏或显示单实例工具窗口，而多实例工具窗口可以关闭并隐藏。 所有工具窗口都可以停靠、选项卡链接、浮动或设置为 Multiple-Document 接口 (MDI) 子窗口 (与文档窗口) 类似。 所有工具窗口都应在 "窗口" 菜单中响应适当的窗口管理命令：

!["Visual Studio 窗口" 菜单中的窗口管理命令](../../extensibility/ux-guidelines/media/0702-03_windowmanagementcontrols.png "0702-03_WindowManagementControls")<br />"Visual Studio 窗口" 菜单中的窗口管理命令

#### <a name="document-specific-tool-windows"></a>文档特定的工具窗口
某些工具窗口旨在根据给定类型的文档进行更改。 这些 windows 不断更新，以反映适用于 IDE 中的活动文档窗口的功能。

"工具箱" 和 "文档大纲" 中其内容更改以反映所选编辑器的工具窗口的示例。 当编辑器有焦点不提供窗口上下文时，这些窗口将显示水印。

#### <a name="navigable-list-tool-windows"></a>可导航列表工具窗口
某些工具窗口显示用户可与之交互的可导航项的列表。 在此类型的窗口中，对于列表中的当前项应始终有反馈，即使窗口处于非活动状态也是如此。 此列表还应通过更改窗口中当前选定的项来响应 **GoToNextLocation** 和 **GoToPrevLocation** 命令。

可导航列表工具窗口的示例包括 "解决方案资源管理器" 和 "查找结果" 窗口。

### <a name="tool-window-types"></a>工具窗口类型

#### <a name="common-tool-windows-and-their-functions"></a>常见工具窗口及其功能

**分层工具窗口**

| 工具窗口 | 功能 |
| --- | --- |
| “解决方案资源管理器” | 显示项目、杂项文件和解决方案项中包含的文档列表的层次结构树。 项目中项的显示由拥有项目类型的包定义 (例如，基于引用、基于目录或混合模式的类型) 。 |
| 类视图 | 类和文档工作集中各个元素的层次结构树，独立于文件本身。 |
| 服务器资源管理器 | 显示解决方案中所有服务器和数据连接的层次结构树。 |
| 文档大纲 | 活动文档的层次结构。 |

**网格工具窗口**

| 工具窗口 | 功能 |
| --- | --- |
| 属性 | 该网格显示所选对象的属性列表，以及值选取器来编辑这些属性。 |
| 任务列表 | 允许用户创建/编辑/删除任务和注释的网格。 |

**内容工具窗口**

| 工具窗口 | 功能 |
| --- | --- |
| 帮助 | 允许用户从 "如何实现" 访问获得帮助的各种方法的窗口 视频到 MSDN 论坛。 |
| 动态帮助 | 显示适用于当前所选内容的帮助主题的链接的工具窗口。 |
| 对象浏览器 | 一个包含两列的框架集，其中包含左窗格中的分层对象组件列表，以及右侧列中对象的属性和方法。 |

**对话框工具窗口**

| 工具窗口 | 功能 |
| --- | --- |
| 查找 | 此对话框允许用户在解决方案内的各种文件中查找或查找和替换。 |
| 高级查找 | 此对话框允许用户在解决方案内的各种文件中查找或查找和替换。 |

**其他工具窗口**

::: moniker range="vs-2017"

| 工具窗口 | 功能 |
| --- | --- |
| 工具箱 | 用于存储将放置到设计图面上的元素的工具窗口，为所有设计器提供一致的拖放。 |
| 起始页 | 用户的门户，Visual Studio 访问开发人员新闻、Visual Studio 帮助和最新项目的源。 用户还可以通过以下方式创建自定义起始页：将 "Common7\IDE\StartPages" 文件从 "Visual Studio" 文件 \" 目录复制到 "Visual Studio documents" 目录中的 "StartPages" 文件夹，然后手动编辑该 xaml 或在 Visual Studio 或其他代码编辑器中打开它。 |

::: moniker-end

::: moniker range=">=vs-2019"

| 工具窗口 | 功能 |
| --- | --- |
| 工具箱 | 用于存储将放置到设计图面上的元素的工具窗口，为所有设计器提供一致的拖放。 |

::: moniker-end

**调试器工具窗口**

| 工具窗口 | 功能 |
| --- | --- |
| 自动 ||
| 即时 ||
| 输出 | 如果要声明文本事件或状态，则可以使用 "输出" 窗口。 |
| 内存 ||
| 断点 ||
| 运行 ||
| 文档 ||
| 调用堆栈 ||
| 局部变量 ||
| 监视 ||
| 反汇编 ||
| 寄存器 ||
| 线程数 ||

## <a name="document-editor-conventions"></a><a name="BKMK_DocumentEditorConventions"></a> 文档编辑器约定

### <a name="document-interactions"></a>文档交互
"文档很好" 是 IDE 中的最大空间，用户通常会重点关注如何完成其任务，如补充工具窗口。 文档编辑器表示用户在 Visual Studio 中打开并保存的基本工作单元。 它们保持了与解决方案资源管理器或其他活动层次结构窗口相关的更好选择。 用户应该能够指向这些层次结构窗口中的一个窗口，知道文档包含的位置及其与解决方案、项目或 Visual Studio 包提供的其他根对象之间的关系。

文档编辑需要一致的用户体验。 若要允许用户将精力集中在任务上，而不是使用窗口管理和查找命令，请选择最适合于编辑该文档类型的用户任务的文档视图策略。

#### <a name="common-interactions-for-the-document-well"></a>文档的常见交互

- 在常见的 **新文件** 中维护一致的交互模型，并 **打开文件** 体验。

- 当文档窗口打开时，更新相关窗口和菜单中的相关功能。

- 菜单命令已适当地集成到常见菜单中，如 **编辑**、 **格式** 和 **视图** 菜单。 如果有大量专用命令可用，则可以创建一个新菜单。 只有当文档具有焦点时，才应显示此新菜单。

- 可以将嵌入的工具栏放置在编辑器的顶部。 这比在编辑器外显示单独的工具栏更好。

- 始终在解决方案资源管理器或类似的活动层次结构窗口中维护选定内容。

- 双击解决方案资源管理器中的文档应执行与 **Open** 相同的操作。

- 如果有多个编辑器可用于某个文档类型，用户应该能够通过右键 **单击该文件** 并从快捷菜单中选择 " **打开** 方式"，来覆盖或重置给定文档类型的默认操作。

- 不要在文档中创建向导。

### <a name="user-expectations-for-specific-document-types"></a>特定文档类型的用户预期
文档编辑器有几种不同的基本类型，每种类型都有一组与其他类型的交互一致的交互。

- **基于文本的编辑器：** 代码编辑器、日志文件

- **设计图面：** WPF 窗体设计器，Windows 窗体

- **对话框样式编辑器：** 清单设计器，项目属性

- **模型设计器：** 工作流设计器，codemap，体系结构关系图，进度

还有多个使用该文档的非编辑器类型。 虽然它们不会自行编辑文档，但需要遵循文档窗口的标准交互。

- **报表：** IntelliTrace 报表，Hyper-v 报表，探查器报表

- **仪表板：** 诊断中心

#### <a name="text-based-editors"></a>基于文本的编辑器

- 文档参与 "预览" 选项卡模型，允许预览文档而不打开它。

- 文档的结构可以在伴生工具窗口（如文档大纲）中表示。

- 如果适当的) 将与其他代码编辑器的行为一致，则 IntelliSense (。

- 对于现有类似的 UI （如 CodeLens），弹出式窗口或辅助 UI 遵循类似的样式和模式。

- 有关文档状态的消息将显示在文档顶部或状态栏中的 "信息栏" 控件中。

- 用户必须可以使用 "工具" > "选项" 页上的 " **工具** "、"共享字体和颜色" 页或特定于编辑器的工具来自定义字体和颜色的外观。

#### <a name="design-surfaces"></a>设计图面

- 空设计器的图面上应有一个水印，指示如何开始使用。

- 视图切换机制将遵循现有模式，如双击以打开代码编辑器，或允许与这两个窗格进行交互的文档窗口中的选项卡。

- 将元素添加到设计图面应通过工具箱完成，除非需要高度特定的工具窗口。

- 图面上的项将遵循一致的选择模型。

- 嵌入工具栏仅包含特定于文档的命令，而不包含 **保存** 等常见命令。

#### <a name="dialog-style-editors"></a>对话框样式编辑器

- 控件布局应遵循普通的对话框布局约定。

- 编辑器中的选项卡不应与文档选项卡的外观匹配，它们应与两个允许的内部选项卡样式之一匹配。

- 用户必须能够仅使用键盘与控件交互;通过激活编辑器并按 tab 键或使用标准的助记键来切换。

- 设计器应使用通用保存模型。 不应将整体的 "保存" 或 "提交" 按钮放置在表面上，尽管其他按钮可能适用。

#### <a name="model-designers"></a>模型设计器

- 空设计器的图面上应有一个水印，指示如何开始使用。

- 将元素添加到设计图面应通过工具箱完成。

- 图面上的项将遵循一致的选择模型。

- 嵌入工具栏仅包含特定于文档的命令，而不包含 **保存** 等常见命令。

- 图例可能出现在表面上，即指示或水印。

- 用户必须可以使用 " **工具" > "选项** " 页上的 "工具"、"共享字体和颜色" 页或特定于编辑器的工具来自定义字体/颜色的外观。

#### <a name="reports"></a>报表

- 报表通常只是信息信息，不参与保存模型。 但它们可能包含交互，如指向其他相关信息的链接或展开和折叠的部分。

- 图面上的大多数命令都应为超链接，而不是按钮。

- 布局应包括标题，并遵循标准报表布局准则。

#### <a name="dashboards"></a>仪表板

- 仪表板本身没有交互模型，但作为一种提供各种其他工具的方法。

- 它们不参与保存模型。

- 用户只有通过激活编辑器并按 tab 键或使用标准的助记键，才能使用键盘与控件进行交互。

## <a name="dialogs"></a><a name="BKMK_Dialogs"></a> 对话

### <a name="introduction"></a>简介
Visual Studio 中的对话通常应支持用户工作的一个离散单元，然后将其解除。

如果已确定需要对话框，可以按优先选择的顺序进行三个选择：

1. 将功能集成到 Visual Studio 中的某个共享对话框。

2. 使用在现有类似对话框中找到的模式创建自己的对话框。

3. 按照交互和布局准则创建新的对话框。

本部分介绍如何在 Visual Studio 工作流中选择正确的对话模式，以及如何在对话设计中选择通用约定。

### <a name="themes"></a>主题
Visual Studio 中的对话框采用以下两种基本样式之一：

#### <a name="standard-unthemed"></a>标准 (unthemed) 
大多数对话框都是标准实用工具对话框，应 unthemed。 不要重新对公共控件进行模板化或尝试创建风格的 "新式" 按钮或控件。 控件和 chrome 外观按照[标准 Windows 对话框的桌面交互指南](/windows/desktop/uxguide/win-dialog-box)。

#### <a name="themed"></a>主题
专业的 "签名" 对话框可能有主题。 主题对话框具有不同的外观，这也有一些与样式关联的特殊交互模式。 仅当对话框符合以下要求时才对其进行主题：

- 此对话框是通常情况下或由许多用户使用的常见体验，如 "**新建 Project** " 对话框 (。

- 此对话框包含突出的产品品牌元素 (例如，) **帐户设置** 对话框。

- 此对话框显示为包含其他主题对话框的较大流的组成部分， (例如，" **添加连接的服务** " 对话框) 。

- 此对话框是体验的重要部分，在提升或区分产品版本方面扮演战略角色。

创建主题对话框时，请使用适当的环境颜色，并遵循正确的布局和交互模式。  (参阅[Visual Studio 的布局](../../extensibility/ux-guidelines/layout-for-visual-studio.md)。 ) 

### <a name="dialog-design"></a>对话框设计
设计良好的对话框会考虑以下元素：

- 受支持的用户任务

- 对话框文本样式、语言和术语

- 控制选择和 UI 约定

- 视觉布局规范和控件对齐

- 键盘访问

#### <a name="content-organization"></a>内容组织
请考虑这种基本类型的对话框之间的差异：

- [简单对话框](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs) 在单个模式窗口中显示控件。 此演示可能包含复杂控件模式的变体，包括字段选取器或图标栏。

- 当一段 UI 包含多组控件时，[分层对话](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs)用于充分利用屏幕空间。 该对话框的分组通过选项卡控件、导航列表控件或按钮 "分层"，以便用户可以选择在任何给定时刻要查看的分组。

- [向导](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards) 可用于将用户的逻辑顺序定向到任务完成。 顺序面板中提供了一系列选项，有时会引入不同的工作流 ( "分支" ) 依赖于上一面板中所做的选择。

#### <a name="simple-dialogs"></a><a name="BKMK_SimpleDialogs"></a> 简单对话框
一个简单的对话框是在单个模式窗口中显示控件。 此演示可能包含复杂控件模式的变体，如字段选取器。 对于简单对话框，请遵循标准一般布局以及复杂控件分组所需的任何特定布局。

![>创建强名称密钥是 Visual Studio 中简单对话框的示例。](../../extensibility/ux-guidelines/media/0704-01_createstrongnamekey.png "0704-01_CreateStrongNameKey")<br />创建强名称密钥是 Visual Studio 中简单对话框的示例。

#### <a name="layered-dialogs"></a><a name="BKMK_LayeredDialogs"></a> 分层对话
分层对话框包含选项卡、仪表板和嵌入树。 当单个 UI 中提供了多个控件组时，它们用于最大化房地产。 对分组进行分层，以便用户可以选择随时查看的分组。

在最直接的情况下，在分组之间切换的机制是选项卡控件。 有几种替代方法可用。 请参阅确定优先级和分层，了解如何选择最合适的样式。

" **工具 &gt; 选项** "对话框是使用嵌入树的分层对话的示例：

![">选项"是"选项"中分层对话框Visual Studio。](../../extensibility/ux-guidelines/media/0704-02_toolsoptions.png "0704-02_ToolsOptions")<br />">选项"是"工具""选项"中的分层Visual Studio。

#### <a name="wizards"></a><a name="BKMK_Wizards"></a> 向导
向导可用于指导用户完成任务的逻辑步骤序列。 顺序面板中提供了一系列选项，用户必须继续执行每个步骤，然后才能继续下一步。 有足够的默认值可用后，将启用 **"完成** "按钮。

 模式向导用于以下任务：

- 包含分支，其中提供不同的路径，具体取决于用户选择

- 包含步骤之间的依赖关系，其中后续步骤依赖于上一步骤中的用户输入 () 

- 足够复杂，应该使用 UI 解释所提供的选择以及每个步骤中可能的结果

- 是事务性的，要求在提交任何更改之前完整完成一组步骤

### <a name="common-conventions"></a>常见约定
若要通过对话实现最佳设计和功能，请遵循有关对话框大小、位置、标准、控制配置和对齐、UI 文本、标题栏、控制按钮和访问键的这些约定。

有关特定于布局的准则，请参阅[布局Visual Studio。](../../extensibility/ux-guidelines/layout-for-visual-studio.md)

#### <a name="size"></a>大小
对话应不超过 1024x768 屏幕分辨率，初始对话大小不应超过 900x700 像素。 对话框可以调整大小，但这不是一项要求。

对于可调整大小的对话，有两条建议：

1. 该最小大小是为对话框定义的，该对话框将针对控件集进行优化而不进行剪辑，并进行调整以适应合理的本地化增长。

2. 用户缩放的大小在会话与会话保持一样。 例如，如果用户将对话缩放为 150%，则对话框的后续启动将显示为 150%。

#### <a name="position"></a>位置
首次启动时，对话框必须在 IDE 中居中显示。 不可调整大小对话的最后一个位置不需要持久化，因此它们将在后续启动时居中显示。

对于可调整大小的对话，应在后续启动时保留大小。 对于可调整大小的模式对话，无需保留位置。 在 IDE 中居中显示它们可防止对话框在用户的显示配置发生更改时出现在不可预知或不可用的位置。

对于可重新定位的无模式对话，应在后续启动时保持用户的位置，因为对话可能经常用作较大工作流的组成部分。

当对话必须生成其他对话时，最顶层的对话应从父级向右和向下级联，以便用户可以明显看到它们已导航到新位置。

#### <a name="modality"></a>形态
作为模式意味着用户需要先完成或取消对话，然后才能继续。 由于模式对话会阻止用户与环境的其他部分交互，因此功能的任务流应尽量少使用它们。 当需要模式操作时，Visual Studio多个共享对话，你可以将功能集成到其中。 如果必须创建新对话，请遵循具有类似功能的现有对话的交互模式。

当用户需要一次执行两个活动（如在编写新代码时查找和替换）时，对话框应为无模式，以便用户可以轻松切换它们。 Visual Studio此类支持编辑器的链接任务，通常使用工具窗口。

#### <a name="control-configuration"></a>控制配置
与现有的控制配置保持一致，这些配置在Visual Studio。

#### <a name="title-bars"></a>标题栏

- 标题栏中的文本必须反映启动它的命令的名称。

- 不应在对话框标题栏内使用图标。 如果系统需要一个，请使用Visual Studio徽标。

- 对话框不应具有最小化或最大化按钮。

- 标题栏中的帮助按钮已弃用。 请勿将它们添加到新对话框中。 它们存在时，应启动与任务相关的概念帮助主题。

  ![对话框中标题栏Visual Studio规范](../../extensibility/ux-guidelines/media/0704-03_titlebarspecs.png "0704-03_TitleBarSpecs")<br />对话框中标题栏Visual Studio规范

#### <a name="control-buttons"></a>控件按钮
通常 **，"确定****"、"** 取消 **"** 和"帮助"按钮应水平排列在对话框右下角。 如果对话框底部有几个其他按钮，则允许使用备用垂直堆栈，这些按钮会导致与控件按钮产生视觉混淆。

![对话框中控制按钮的可接受Visual Studio配置](../../extensibility/ux-guidelines/media/0704-04_controlbuttonconfig.png "0704-04_ControlButtonConfig")<br />对话框中控制按钮的可接受Visual Studio配置

该对话框必须包含默认控件按钮。 若要确定用作默认值的最佳命令，请从以下选项中进行选择 (按优先级顺序) ：

- 选择最安全且最安全的命令作为默认值。 这意味着选择命令最有可能防止数据丢失并避免意外的系统访问。

- 如果数据丢失和安全性不是因素，请根据便利性选择默认命令。 当对话框支持频繁或重复的任务时，将最可能的命令包括为默认值将改进用户的工作流。

避免为默认命令选择永久破坏性操作。 如果存在此类命令，请改为选择更安全的命令作为默认值。

#### <a name="access-keys"></a>访问密钥
请勿将访问密钥用于 **"确定"、"****取消**"或"**帮助"** 按钮。 默认情况下，这些按钮映射到快捷键：

| 按钮名称 | 键盘快捷键 |
| --- | --- |
| 确定 | Enter |
| 取消 | Esc |
| 帮助 | F1 |

#### <a name="imagery"></a>图像
在对话框中谨慎使用图像。 请勿在对话框中使用大图标，而只是占用空间。 只有在图像是向用户传达消息的重要部分（如警告图标或状态动画）时，才使用图像。

### <a name="prioritizing-and-layering"></a><a name="BKMK_PrioritizingAndLayering"></a> 确定优先级和分层

#### <a name="prioritizing-your-ui"></a>确定 UI 的优先级
可能需要将某些 UI 元素放在最前面，将更高级的行为和选项放在 (包括模糊命令) 对话框中。 通过为常用功能提供空间，在显示对话框时在 UI 中默认使用文本标签使其可见，从而将常用功能引入最前面。

#### <a name="layering-your-ui"></a>对 UI 进行分层
如果已确定对话框是必需的，但要呈现给用户的相关功能超出了简单对话框中可显示的功能，则需要对 UI 进行分层。 最常用的分层方法Visual Studio选项卡、仪表板或仪表板。 在某些情况下，可以展开和折叠的区域可能很合适。 通常不建议在应用Visual Studio。

通过类似选项卡的控件对 UI 进行分层的不同方法有优点和缺点。 查看以下列表，确保选择适合你的情况的分层技术。

##### <a name="tabbing"></a>Tab 键次序

| 切换机制 | 优点和适当使用 | 缺点和不当使用 |
| --- | --- | --- |
| Tab 控件 | 以逻辑方式将对话框页分组到相关集<br /><br />对于少于五个 (或对话框中一行的选项卡数非常有用，) 对话框中相关控件的页面<br /><br />选项卡标签必须短：一个或两个可以轻松识别内容的单词<br /><br />通用系统对话样式<br /><br />示例 **：文件资源管理器 &gt; 项属性** | 制作描述性短标签可能很困难<br /><br />通常不会在一个对话框中缩放过去五个选项卡<br /><br />如果一行的选项卡过多，则 (另一种分层技术) <br /><br />不可扩展 |
| 边栏导航 | 可以容纳比选项卡更多的类别的简单切换设备<br /><br />没有层次结构的 (列表) <br /><br />可扩展<br /><br />示例： **自定义... &gt; 添加命令** | 如果少于三个组，则不能充分利用水平空间<br /><br />任务可能更适合下拉列表 |
| 树控件 | 允许无限制的类别<br /><br />允许对类别进行分组和/或层次结构<br /><br />可扩展<br /><br />示例： **工具 &gt; 选项** | 高度嵌套的层次结构可能导致过多的水平滚动<br /><br />Visual Studio树视图过度 |
| 向导 | 通过指导用户完成基于任务的有序步骤来帮助完成任务：向导表示高级任务，单个面板表示完成整个任务所需的子任务<br /><br />当任务跨越 Ui 边界时非常有用，就像用户必须使用多个编辑器和工具窗口来完成任务一样<br /><br />当任务需要分支时很有用<br /><br />当任务包含步骤之间的依赖关系时很有用<br /><br />当多个具有一个决策分叉的类似任务可以在一个对话框中显示以减少不同相似对话的数量时非常有用 | 不适合于不需要顺序工作流的任何任务<br /><br />如果向导步骤过多，用户可能会感到重负和困惑<br /><br />向导的屏幕空间本质上受到限制 |

##### <a name="hallways-or-dashboards"></a>仪表板或仪表板
仪表板和仪表板是充当其他对话框和窗口的启动点的对话框或面板。 设计良好的"浮点"会立即显示最常见的选项、命令和设置，允许用户轻松完成常见任务。 如同现实世界中的空调提供用于访问其后面房间的门道一样，此处不太常见的 UI 被收集到单独的"房间"中 (通常其他对话) 包括可以从主要空调访问的相关功能。

或者，在单个集合中提供所有可用功能的 UI，而不是将不太常见的功能重构到单独的位置，只是一个仪表板。

![用于公开其他 UI 的元概念Outlook](../../extensibility/ux-guidelines/media/0704-08_hallway.png "0704-08_Hallway")<br />用于公开其他 UI 的Outlook

##### <a name="adaptive-ui"></a>自适应 UI
根据使用情况或用户的自我报告体验显示或隐藏 UI 是在隐藏其他部分的同时呈现所需 UI 的另一种方法。 不建议在Visual Studio，因为决定何时显示或隐藏 UI 的算法可能比较棘手，并且某些情况的规则始终会出错。

## <a name="projects"></a><a name="BKMK_Projects"></a> 项目

### <a name="projects-in-the-solution-explorer"></a>项目中的项目解决方案资源管理器
大多数项目都归类为基于引用、基于目录或混合项目。 所有三种类型的项目都同时在 解决方案资源管理器。 使用项目时用户体验的根在此窗口中进行。 尽管不同的项目节点是引用、目录或混合模式类型项目，但存在一种常见的交互模式，应该先应用该模式作为起点，然后再进入特定于项目的用户模式。

项目应始终：

- 支持添加项目文件夹以组织项目内容的能力

- 维护一致的项目持久性模型

项目还应维护一致的交互模型，用于：

- 删除项目项

- 保存文档

- Project属性编辑

- 在备用视图中编辑项目

- 拖放操作

### <a name="drag-and-drop-interaction-model"></a>拖放交互模型
项目通常将自身分类为基于引用的 (只能保留对存储) 中的项目项的引用、基于目录的 (只能持久保存实际存储在项目层次结构) 中的项目项，或能够保留引用或物理项) 的混合 (。 IDE 在 解决方案资源管理器 中同时容纳所有三 **解决方案资源管理器。**

从拖放的角度来看，以下特征应适用于项目组内的 **解决方案资源管理器：**

- **基于引用的项目：** 关键点是，项目正在拖动对存储中项的引用。 当基于引用的项目充当移动操作源时，它只应从项目中删除对该项的引用。 实际上不应从硬盘驱动器中删除该项。 当基于引用的项目充当移动 (或复制) 操作的目标时，它应添加对原始源项的引用，而无需创建项的专用副本。

- **基于目录的项目：** 从拖放视图来看，项目是在物理项（而不是引用）周围拖动。 当基于目录的项目充当移动操作的来源时，它最终应从硬盘驱动器中删除物理项，以及从项目中删除它。 当基于目录的项目充当移动或 (或复制) 的目标时，它应在目标位置创建源项的副本。

- **混合目标项目：** 从拖放的角度来看，此类项目的行为基于所拖动项的性质 (引用存储中的项或项本身) 。 上面描述了引用和物理项的正确行为。

如果项目中只有一种类型的项目 **解决方案资源管理器，则** 拖放操作将非常简单。 由于每个项目系统都能够定义自己的拖放行为，因此应遵循基于 Windows Explorer 拖放行为 (的某些准则) 以确保可预测的用户体验：

- 当 Ctrl 和 Shift键都解决方案资源管理器 (Shift 键时，) 拖动操作会导致移动操作。

- 移位拖动操作还应导致移动操作。

- Ctrl 拖动操作应会导致复制操作。

- 基于引用的项目系统和混合项目系统支持将链接 (或引用) 源项的概念。 当这些项目是拖放操作的目标时 (在 **Ctrl + Shift**) 时，它应导致对添加到项目的项的引用

并非所有拖放操作在基于引用、基于目录的项目和混合项目的组合中都是合理的。 具体而言，假定允许在基于目录的源项目与基于引用的目标项目之间移动操作是有问题的，因为基于源目录的项目在移动完成后必须删除源项。 然后，基于目标引用的项目将最终获得对已删除项的引用。

如果假定允许在这些类型的项目之间执行复制操作，也具有误导性，因为基于引用的目标项目不应创建源项的独立副本。 同样，不应允许 Ctrl + Shift 拖动到基于目录的目标项目，因为基于目录的项目无法保留引用。 如果不支持拖放操作，IDE 应禁止拖放，并向用户显示无拖放光标 (如下面的指针表所示) 。

若要正确实现拖放行为，拖动的源项目需要将其性质传达给目标项目。  (例如，它是基于引用还是基于目录？) 此信息由源提供的剪贴板格式指示。 作为拖动源 (或剪贴板复制操作) 项目应分别提供 或 ，具体取决于项目是基于引用还是 `CF_VSREFPROJECTITEMS` `CF_VSSTGPROJECTITEMS` 基于目录。 这两种格式具有相同的数据内容，这类似于 Windows 格式，只不过字符串列表（而不是文件名）是字符串的双终止列表 (根据情况从 或) `CF_HDROP` `NULL` `Projref` `IVsSolution::GetProjrefOfItem` `::GetProjrefOfProject` 返回。

作为拖放 (或剪贴板粘贴操作) 的目标，项目应同时接受 和 ，但拖放操作的确切处理因目标项目和源项目的性质而异。 `CF_VSREFPROJECTITEMS` `CF_VSSTGPROJECTITEMS` 源项目通过提供 还是 来声明 `CF_VSREFPROJECTITEMS` 其性质 `CF_VSSTGPROJECTITEMS` 。 放置的目标了解其自身的性质，因此有足够的信息来决定是否应执行移动、复制或链接。 用户还通过按 Ctrl、Shift 或 Ctrl 和 Shift 键来修改应执行的拖放操作。 放置目标必须正确指示将在其 和 方法中提前执行的操作 `DragEnter` `DragOver` 。 用户 **解决方案资源管理器** 自动知道源项目和目标项目是否相同。

具体不支持将项目项Visual Studio (实例之间拖动，例如，从 devenv.exe 实例拖动) 另一个实例。 此外 **解决方案资源管理器** 直接禁用此功能。

用户应始终能够通过选择项、将其拖动到目标位置并观察以下鼠标指针中的哪一个在删除该项之前显示来确定拖放操作的效果：

| 鼠标指针 | 命令 | 说明 |
| :---: | --- | --- |
| ![鼠标“不放下”图标](../../extensibility/ux-guidelines/media/0706-01_mousenodrop.png "0706-01_MouseNoDrop") | 无删除 | 无法将项删除到指定位置。 |
| ![鼠标“复制”图标](../../extensibility/ux-guidelines/media/0706-02_mousecopy.png "0706-02_MouseCopy") | 复制 | 项将被复制到目标位置。 |
| ![鼠标“移动”图标](../../extensibility/ux-guidelines/media/0706-03_mousemove.png "0706-03_MouseMove") | 移动 | 项将移动到目标位置。 |
| ![鼠标“添加引用”图标](../../extensibility/ux-guidelines/media/0706-04_mouseaddref.png "0706-04_MouseAddRef") | 添加引用 | 对所选项的引用将添加到目标位置。 |

#### <a name="reference-based-projects"></a>基于引用的项目
 下表汇总了拖放 (以及根据基于引用的目标项目按下的源项和修改键的性质，应执行的剪切/复制/粘贴) 操作：

| 修饰符 | 类别 | 源项：引用/链接 | 源项：物理项或文件系统 (`CF_HDROP`)  |
| --- | --- | --- | --- |
| No 修饰符 | 操作 | 移动 | 链接 |
| No 修饰符 | 目标 | 添加对原始项的引用 | 添加对原始项的引用 |
| No 修饰符 | 源 | 删除对原始项的引用 | 保留原始项 |
| No 修饰符 | 结果 | `DROPEFFECT_MOVE` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | `DROPEFFECT_LINK` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 |
| Shift + 拖动 | 操作 | 移动 | 不删除 |
| Shift + 拖动 | 目标 | 添加对原始项的引用 | 不删除 |
| Shift + 拖动 | 源 | 删除对原始项的引用 | 不删除 |
| Shift + 拖动 | 结果 | `DROPEFFECT_MOVE` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | 不删除 |
| Ctrl + 拖动 | 操作 | 复制 | 不删除 |
| Ctrl + 拖动 | 目标 | 添加对原始项的引用 | 不删除 |
| Ctrl + 拖动 | 源 | 保留对原始项的引用 | 不删除 |
| Ctrl + 拖动 | 结果 | `DROPEFFECT_COPY` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | 不删除 |
| Ctrl + Shift + 拖动 | 操作 | 链接 | 链接 |
| Ctrl + Shift + 拖动 | 目标 | 添加对原始项的引用 | 添加对原始项的引用 |
| Ctrl + Shift + 拖动 | 源 | 保留对原始项的引用 | 保留原始项 |
| Ctrl + Shift + 拖动 | 结果 | `DROPEFFECT_LINK` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | `DROPEFFECT_LINK` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 |
| Ctrl + Shift + 拖动 | 备注 | 与 Windows 资源管理器中快捷方式的拖放行为相同。 ||
| 剪切/粘贴 | 操作 | 移动 | 链接 |
| 剪切/粘贴 | 目标 | 添加对原始项的引用 | 添加对原始项的引用 |
| 剪切/粘贴 | 源 | 保留对原始项的引用|保留原始项 |
| 剪切/粘贴 | 结果 | 项目保留在存储中的原始位置 | 项目保留在存储中的原始位置 |
| 复制/粘贴 | 操作 | 复制 | 链接 |
| 复制/粘贴 | 源 | 添加对原始项的引用 | 添加对原始项的引用 |
| 复制/粘贴 | 结果 | 保留对原始项的引用 | 保留原始项 |
| 复制/粘贴 | 操作 | 项保留在存储中的原始位置 | 项保留在存储中的原始位置 |

#### <a name="directory-based-projects"></a>基于目录的项目
下表汇总了拖放 (以及应该根据为基于目录的目标项目按下的源项和修饰符键的性质执行的剪切/复制/粘贴) 操作：

| 修饰符 | 类别 | 源项：引用/链接 | 源项：物理项或文件系统 `CF_HDROP` ()  |
|-----------------|----------| - | - |
| 无修饰符 | 操作 | 移动 | 移动 |
| 无修饰符 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| 无修饰符 | 源 | 删除对原始项的引用 | 删除对原始项的引用 |
| Shift+拖动 | 操作 | 移动 | 移动 |
| Shift+拖动 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| Shift+拖动 | 源 | 删除对原始项的引用 | 从原始位置删除项 |
| Shift+拖动 | 结果 | `DROPEFFECT_MOVE` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | `DROPEFFECT_MOVE` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 |
| Ctrl+拖动 | 操作 | 复制 | 复制 |
| Ctrl+拖动 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| Ctrl+拖动 | 源 | 保留对原始项的引用 | 保留对原始项的引用 |
| Ctrl+拖动 | 结果 | `DROPEFFECT_COPY` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | `DROPEFFECT_COPY` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 |
| Ctrl+Shift+拖动 | | 无删除 | 无删除 |
| 剪切/粘贴 | 操作 | 移动 | 移动 |
| 剪切/粘贴 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| 剪切/粘贴 | 源 | 删除对原始项的引用 | 从原始位置删除项 |
| 剪切/粘贴 | 结果 | 项保留在存储中的原始位置 | 从存储中的原始位置删除项 |
| 复制/粘贴 | 操作 | 复制 | 复制 |
| 复制/粘贴 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| 复制/粘贴 | 源 | 保留原始项 | 保留原始项 |
| 复制/粘贴 | 结果 | 项保留在存储中的原始位置 | 项保留在存储中的原始位置 |

#### <a name="mixed-target-projects"></a>混合目标项目
下表汇总了拖放 (，以及基于为混合目标项目按下的源项和修改键的性质，应执行的剪切/复制/粘贴) 操作：

| 修饰符 | 类别 | 源项：引用/链接 | 源项：物理项或文件系统 (`CF_HDROP`)  |
| --- | --- | --- | --- |
| No 修饰符 | 操作 | 移动 | 移动 |
| No 修饰符 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| No 修饰符 | 源 | 删除对原始项的引用 | 删除对原始项的引用 |
| No 修饰符 | 结果 | `DROPEFFECT_ MOVE` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | `DROPEFFECT_ MOVE` 作为的操作返回 `::Drop` ，从存储中的原始位置删除项 |
| Shift + 拖动 | 操作 | 移动 | 移动 |
| Shift + 拖动 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| Shift + 拖动 | 源 | 删除对原始项的引用 | 从原始位置删除项 |
| Shift + 拖动 | 结果 | `DROPEFFECT_ MOVE` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | `DROPEFFECT_ MOVE` 作为的操作返回 `::Drop` ，从存储中的原始位置删除项 |
| Ctrl + 拖动 | 操作 | 复制 | 复制 |
| Ctrl + 拖动 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| Ctrl + 拖动 | 源 | 保留对原始项的引用 | 保留原始项 |
| Ctrl + 拖动 | 结果 | `DROPEFFECT_ COPY` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | `DROPEFFECT_ COPY` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 |
| Ctrl + Shift + 拖动 | 操作 | 链接 | 链接 |
| Ctrl + Shift + 拖动 | 目标 | 添加对原始项的引用 | 添加对原始源项的引用 |
| Ctrl + Shift + 拖动 | 源 | 保留对原始项的引用 | 保留原始项 |
| Ctrl + Shift + 拖动 | 结果 | `DROPEFFECT_ LINK` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | `DROPEFFECT_ LINK` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 |
| 剪切/粘贴 | 操作 | 移动 | 移动 |
| 剪切/粘贴 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| 剪切/粘贴 | 源 | 删除对原始项的引用 | 从原始位置删除项 |
| 剪切/粘贴 | 结果 | 项目保留在存储中的原始位置 | 从存储中的原始位置删除项目 |
| 复制/粘贴 | 操作 | 复制 | 复制 |
| 复制/粘贴 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| 复制/粘贴 | 源 | 保留原始项 | 保留原始项 |
| 复制/粘贴 | 结果 | 项目保留在存储中的原始位置 | 项目保留在存储中的原始位置 |

在 **解决方案资源管理器** 中实现拖动时，应考虑这些详细信息：

- 设计多选方案。

- 文件名称 (完整路径) 在目标项目中必须是唯一的，否则不允许放置。

- 文件夹名称必须是唯一的， (不区分大小写的) 。

- 在拖动时打开或关闭的文件之间存在行为差异 (未在上述方案中提到) 。

- 顶级文件的行为与文件夹中的文件略有不同。

要注意的另一个问题是如何处理已打开设计器或编辑器的项的移动操作。 预期行为如下 (这适用于所有项目类型) ：

1. 如果打开的编辑器/设计器没有任何未保存的更改，则编辑器/设计器窗口应以静默方式关闭。

2. 如果打开的编辑器/设计器确实有未保存的更改，则拖动的源应等待放置操作，然后要求用户在关闭窗口之前保存打开的文档中未提交的更改，并提示如下：

    ```
    ==========================================================
         One or more open documents have unsaved changes.
    Do you want to save uncommitted changes before proceeding?
                      [Yes]  [No]  [Cancel]
    ==========================================================
    ```

这为用户提供了在目标创建副本之前保存正在进行的工作的机会。 添加了一种新方法 `IVsHierarchyDropDataSource2::OnBeforeDropNotify` 来启用此处理。

然后，目标将复制项在存储中的状态，如果用户选择 " **无** ") ，则不在编辑器中包含未保存的更改 (不包含未保存的更改。 目标完成其复制 (`IVsHierarchyDropDataSource::Drop`) 后，就有机会在) 中完成移动操作 (删除部分 `IVsHierarchyDropDataSource::OnDropNotify` 。

具有未保存更改的任何编辑器都应保持打开状态。 对于包含未保存更改的文档，这意味着将执行移动操作的复制部分，但会中止删除部分。 在多选方案中，当用户选择 " **否**" 时，不应关闭或删除那些具有未保存更改的文档，而不保存更改的文档应关闭并删除。
