---
title: Visual Studio 的应用程序模式 |Microsoft Docs
description: 了解文档窗口、工具窗口和无模式对话框之间的差异，包括 Visual Studio 的新功能的窗口使用模式。
ms.custom: SEO-VS-2020
ms.date: 04/26/2017
ms.topic: reference
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
author: leslierichardson95
ms.author: lerich
manager: jmartens
ms.technology: vs-ide-sdk
ms.workload:
- vssdk
ms.openlocfilehash: 189fcf6521daa9385dc2292d40e796d068c637a9a60c54562b52413b65f33b5a
ms.sourcegitcommit: c72b2f603e1eb3a4157f00926df2e263831ea472
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/12/2021
ms.locfileid: "121400650"
---
# <a name="application-patterns-for-visual-studio"></a>Visual Studio 的应用程序模式
## <a name="window-interactions"></a><a name="BKMK_WindowInteractions"></a> 窗口交互

### <a name="overview"></a>概述
Visual Studio 中使用的两种主要窗口类型是文档编辑器和工具窗口。 很少但可能是大的无模式对话框。 尽管这些在 shell 中都是无模式的，但是它们的模式在本质上是不同的。 本部分介绍文档窗口、工具窗口和无模式对话框之间的差异。 [对话框中介绍](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)了模式对话框模式。

### <a name="comparing-window-usage-patterns"></a>比较窗口使用模式
**文档窗口** 几乎始终显示在文档中。 这为文档编辑器提供了一个 "中心阶段"，用于排列补充工具窗口。

**工具窗口** 最常显示为相对 IDE 边缘折叠的单独的小窗口。 这可以是可见、隐藏或自动隐藏。 但是，在文档中，有时会通过取消选中窗口中的 " **窗口"/"停靠** " 属性来显示工具窗口。 这会产生更多真实的内容，但也是一种常见的设计决策：尝试集成到 Visual Studio 时，必须确定功能是否应显示工具窗口或文档窗口。

不建议在 Visual Studio 中进行 **无模式对话框**。 大多数无模式对话框按定义、浮动工具窗口，应以这种方式实现。 如果固定到 shell 一侧的正常工具窗口的大小过大限制，则允许无模式对话框。 在用户可能会将对话框移至辅助监视器的情况下，也可以使用它们。

仔细考虑所需的容器类型。 下表中提供了 UI 设计的常见使用模式注意事项。

||文档窗口|工具窗口|无模式对话框|
|-|---------------------|-----------------|---------------------|
| **位置** | 始终定位在文档中，并且不会停靠在 IDE 的边缘周围。 它可以 "拔出"，使其独立于主外壳。 | 通常，tab 在 IDE 的边缘周围停靠，但可以自定义为浮动、自动隐藏 (取消固定) 或在文档中停靠。|与 IDE 分离的大型浮动窗口。 |
| **提交模型** | *延迟提交*<br /><br /> 若要将数据保存在文档中，用户必须发出 **文件 " &gt; 保存**"、" **另存为**" 或 " **全部保存** " 命令。 文档窗口的概念是 "更新"，然后将其提交到其中一个 "保存" 命令。 关闭文档窗口时，所有内容都将保存到磁盘或丢失。 | *立即提交*<br /><br /> 无保存模式。 对于帮助编辑文件的检查器工具窗口，该文件必须在活动编辑器或设计器中打开，并且编辑器或设计器拥有保存。 | *延迟或立即提交*<br /><br /> 大多数情况下，大型无模式对话框都需要一个操作来提交更改，并允许执行 "取消" 操作，从而回滚在对话会话中所做的任何更改。  这将从该工具窗口中的工具窗口中区分无模式对话框，窗口始终具有即时提交模型。 |
| **可见性** | *打开/创建 (文件) 并关闭*<br /><br /> 打开文档窗口是通过打开现有文档或使用模板创建新文档来完成的。 没有 "打开 \<specific editor> " 命令。 | *隐藏和显示*<br /><br /> 可以隐藏或显示单实例工具窗口。 无论是在视图中还是在隐藏状态，工具窗口中的内容和状态都将保留。 多实例工具窗口可以关闭并隐藏。 当关闭多实例工具窗口时，将放弃工具窗口中的内容和状态。 | *从命令启动*<br /><br /> 从基于任务的命令启动对话框。 |
| **实例** | *多实例*<br /><br /> 可以同时打开多个编辑器和编辑不同的文件，而某些编辑器还允许在多个编辑器中打开相同的文件 (使用 " **&gt; 新建窗口** " 命令) 。<br /><br /> 单个编辑器可以同时编辑一个或多个文件 (Project 设计器) 。 | *单实例或多实例*<br /><br /> 内容将更改以反映上下文 (如属性浏览器中所示) 或将焦点/上下文推送到其他 windows (任务列表解决方案资源管理器) 。<br /><br /> 单实例工具窗口和多实例工具窗口都应与活动文档窗口相关联，除非有很有说服力的原因不是。 | *单实例* |
| **示例** | **文本编辑器**，如代码编辑器<br /><br /> **设计图** 面，如窗体设计器或建模图面<br /><br /> **类似于对话框的控件布局**，如清单设计器 | **解决方案资源管理器** 提供解决方案和解决方案中包含的项目<br /><br /> **服务器资源管理器** 提供用户选择在窗口中打开的服务器和数据连接的层次结构视图。 从数据库层次结构（如查询）打开对象会打开文档窗口，并允许用户编辑查询。<br /><br /> **属性浏览器** 显示在文档窗口或其他工具窗口中选择的对象的属性。 属性在分层网格视图或类似于对话框的复杂控件中提供，并允许用户设置这些属性的值。 | |

## <a name="tool-windows"></a><a name="BKMK_ToolWindows"></a> 工具窗口

### <a name="overview"></a>概述
工具窗口支持在文档窗口中发生的用户工作。 它们可用于显示一个层次结构，该层次结构表示 Visual Studio 提供并可以操作的基础根对象。

考虑在 IDE 中使用新工具窗口时，作者应：

- 使用与任务相对应的现有工具窗口，而不是创建具有类似功能的新工具窗口。 仅当新工具窗口提供了明显不同的 "工具" 或功能，而该工具不能集成到类似的窗口中，或通过将现有窗口转换为透视中心时，才应创建新工具窗口。

- 如果需要，请使用 "工具" 窗口顶部的标准命令栏。

- 与其他工具窗口中已存在的用于控件演示和键盘导航的模式保持一致。

- 与其他工具窗口中的控件表示形式一致。

- 使特定于文档的工具窗口尽可能自动可见，以便仅当激活父文档时才显示这些工具。

- 确保其窗口内容可通过键盘导航 (支持箭头键) 。

#### <a name="tool-window-states"></a>工具窗口状态
Visual Studio 工具窗口具有不同的状态，其中某些状态是用户激活的 (例如自动隐藏功能) 。 其他状态（如 "自动可见"）允许工具窗口出现在正确的上下文中，并在不需要时隐藏。 总共有五个工具窗口状态。

- **停靠/固定** 的工具窗口可以附加到文档区域的四个边。 图钉图标将显示在工具窗口的标题栏中。 工具窗口可以沿 shell 和其他工具窗口的边缘水平或垂直停靠，还可以与选项卡链接在一起。

- **自动隐藏** 的工具窗口已取消固定。 该窗口可以弹出，使选项卡 (的工具窗口的名称，并且其图标) 文档区域的边缘上。 当用户将鼠标指针悬停在选项卡上时，工具窗口将会滑出。

- 当另一段 UI （如编辑器）启动或获得焦点时 **，自动显示的工具窗口** 将自动显示。

- **浮动** 工具窗口在 IDE 外部悬停。 这对于多监视器配置非常有用。

- **选项卡式文档** 工具窗口可停靠在文档中。 这对于大型工具窗口（如对象浏览器）非常有用，它需要更多的房地产，而不是停靠到框架边缘。

![Visual Studio 中的“工具”窗口状态](../../extensibility/ux-guidelines/media/0702-01_toolwindowstates.png "0702-01_ToolWindowStates")<br />Visual Studio 中的“工具”窗口状态

#### <a name="single-instance-and-multi-instance"></a>单实例和多实例
工具窗口是单实例或多实例。 某些单实例工具窗口可能与活动文档窗口相关联，而多实例工具窗口可能不会。 多实例工具窗口通过创建新的窗口实例来响应 **窗口 " &gt; 新建窗口** " 命令。 下图演示了一个工具窗口，该窗口在窗口的实例处于活动状态时启用 "新建窗口" 命令：

![在窗口的实例处于活动状态时启用 "新建窗口" 命令的工具窗口](../../extensibility/ux-guidelines/media/0702-02_toolwindowenablingcommand.png "0702-02_ToolWindowEnablingCommand")<br />在窗口的实例处于活动状态时启用 "新建窗口" 命令的工具窗口

可以隐藏或显示单实例工具窗口，而多实例工具窗口可以关闭并隐藏。 所有工具窗口都可以停靠、选项卡链接、浮动或设置为 Multiple-Document 接口 (MDI) 子窗口 (与文档窗口) 类似。 所有工具窗口都应在 "窗口" 菜单中响应适当的窗口管理命令：

!["Visual Studio 窗口" 菜单中的窗口管理命令](../../extensibility/ux-guidelines/media/0702-03_windowmanagementcontrols.png "0702-03_WindowManagementControls")<br />"Visual Studio 窗口" 菜单中的窗口管理命令

#### <a name="document-specific-tool-windows"></a>文档特定的工具窗口
某些工具窗口旨在根据给定类型的文档进行更改。 这些 windows 不断更新，以反映适用于 IDE 中的活动文档窗口的功能。

"工具箱" 和 "文档大纲" 中其内容更改以反映所选编辑器的工具窗口的示例。 当编辑器有焦点不提供窗口上下文时，这些窗口将显示水印。

#### <a name="navigable-list-tool-windows"></a>可导航列表工具窗口
某些工具窗口显示用户可与之交互的可导航项的列表。 在此类型的窗口中，对于列表中的当前项应始终有反馈，即使窗口处于非活动状态也是如此。 此列表还应通过更改窗口中当前选定的项来响应 **GoToNextLocation** 和 **GoToPrevLocation** 命令。

可导航列表工具窗口的示例包括 "解决方案资源管理器" 和 "查找结果" 窗口。

### <a name="tool-window-types"></a>工具窗口类型

#### <a name="common-tool-windows-and-their-functions"></a>常见工具窗口及其功能

**分层工具窗口**

| 工具窗口 | 函数 |
| --- | --- |
| “解决方案资源管理器” | 显示项目、杂项文件和解决方案项中包含的文档列表的层次结构树。 项目中项的显示由拥有项目类型的包定义 (例如，基于引用、基于目录或混合模式的类型) 。 |
| 类视图 | 类和文档工作集中各个元素的层次结构树，独立于文件本身。 |
| 服务器资源管理器 | 显示解决方案中所有服务器和数据连接的层次结构树。 |
| 文档大纲 | 活动文档的层次结构。 |

**网格工具窗口**

| 工具窗口 | 函数 |
| --- | --- |
| 属性 | 该网格显示所选对象的属性列表，以及值选取器来编辑这些属性。 |
| 任务列表 | 允许用户创建/编辑/删除任务和注释的网格。 |

**内容工具窗口**

| 工具窗口 | 函数 |
| --- | --- |
| 帮助 | 允许用户从 "如何实现" 访问获得帮助的各种方法的窗口 视频到 MSDN 论坛。 |
| 动态帮助 | 显示适用于当前所选内容的帮助主题的链接的工具窗口。 |
| 对象浏览器 | 一个包含两列的框架集，其中包含左窗格中的分层对象组件列表，以及右侧列中对象的属性和方法。 |

**对话框工具窗口**

| 工具窗口 | 函数 |
| --- | --- |
| 查找 | 此对话框允许用户在解决方案内的各种文件中查找或查找和替换。 |
| 高级查找 | 此对话框允许用户在解决方案内的各种文件中查找或查找和替换。 |

**其他工具窗口**

::: moniker range="vs-2017"

| 工具窗口 | 函数 |
| --- | --- |
| 工具箱 | 用于存储将放置到设计图面上的元素的工具窗口，为所有设计器提供一致的拖放。 |
| 起始页 | 用户的门户，Visual Studio 访问开发人员新闻、Visual Studio 帮助和最新项目的源。 用户还可以通过以下方式创建自定义起始页：将 "Common7\IDE\StartPages" 文件从 "Visual Studio" 文件 \" 目录复制到 "Visual Studio documents" 目录中的 "StartPages" 文件夹，然后手动编辑该 xaml 或在 Visual Studio 或其他代码编辑器中打开它。 |

::: moniker-end

::: moniker range=">=vs-2019"

| 工具窗口 | 函数 |
| --- | --- |
| 工具箱 | 用于存储将放置到设计图面上的元素的工具窗口，为所有设计器提供一致的拖放。 |

::: moniker-end

**调试器工具窗口**

| 工具窗口 | 函数 |
| --- | --- |
| 自动 ||
| 即时 ||
| 输出 | 如果要声明文本事件或状态，则可以使用 "输出" 窗口。 |
| 内存 ||
| 断点 ||
| 正在运行 ||
| 文档 ||
| 调用堆栈 ||
| 局部变量 ||
| 监视 ||
| 反汇编 ||
| 寄存器 ||
| 线程数 ||

## <a name="document-editor-conventions"></a><a name="BKMK_DocumentEditorConventions"></a> 文档编辑器约定

### <a name="document-interactions"></a>文档交互
"文档很好" 是 IDE 中的最大空间，用户通常会重点关注如何完成其任务，如补充工具窗口。 文档编辑器表示用户在 Visual Studio 中打开并保存的基本工作单元。 它们保持了与解决方案资源管理器或其他活动层次结构窗口相关的更好选择。 用户应该能够指向这些层次结构窗口中的一个窗口，知道文档包含的位置及其与解决方案、项目或 Visual Studio 包提供的其他根对象之间的关系。

文档编辑需要一致的用户体验。 若要允许用户将精力集中在任务上，而不是使用窗口管理和查找命令，请选择最适合于编辑该文档类型的用户任务的文档视图策略。

#### <a name="common-interactions-for-the-document-well"></a>文档的常见交互

- 在常见的 **新文件** 中维护一致的交互模型，并 **打开文件** 体验。

- 当文档窗口打开时，更新相关窗口和菜单中的相关功能。

- 菜单命令已适当地集成到常见菜单中，如 **编辑**、 **格式** 和 **视图** 菜单。 如果有大量专用命令可用，则可以创建一个新菜单。 只有当文档具有焦点时，才应显示此新菜单。

- 可以将嵌入的工具栏放置在编辑器的顶部。 这比在编辑器外显示单独的工具栏更好。

- 始终在解决方案资源管理器或类似的活动层次结构窗口中维护选定内容。

- 双击解决方案资源管理器中的文档应执行与 **Open** 相同的操作。

- 如果有多个编辑器可用于某个文档类型，用户应该能够通过右键 **单击该文件** 并从快捷菜单中选择 " **打开** 方式"，来覆盖或重置给定文档类型的默认操作。

- 不要在文档中创建向导。

### <a name="user-expectations-for-specific-document-types"></a>特定文档类型的用户预期
文档编辑器有几种不同的基本类型，每种类型都有一组与其他类型的交互一致的交互。

- **基于文本的编辑器：** 代码编辑器、日志文件

- **设计图面：** WPF 窗体设计器，Windows 窗体

- **对话框样式编辑器：** 清单设计器，项目属性

- **模型设计器：** 工作流设计器，codemap，体系结构关系图，进度

还有多个使用该文档的非编辑器类型。 虽然它们不会自行编辑文档，但需要遵循文档窗口的标准交互。

- **报表：** IntelliTrace 报表，Hyper-v 报表，探查器报表

- **仪表板：** 诊断中心

#### <a name="text-based-editors"></a>基于文本的编辑器

- 文档参与 "预览" 选项卡模型，允许预览文档而不打开它。

- 文档的结构可以在伴生工具窗口（如文档大纲）中表示。

- 如果适当的) 将与其他代码编辑器的行为一致，则 IntelliSense (。

- 对于现有类似的 UI （如 CodeLens），弹出式窗口或辅助 UI 遵循类似的样式和模式。

- 有关文档状态的消息将显示在文档顶部或状态栏中的 "信息栏" 控件中。

- 用户必须可以使用 "工具" > "选项" 页上的 " **工具** "、"共享字体和颜色" 页或特定于编辑器的工具来自定义字体和颜色的外观。

#### <a name="design-surfaces"></a>设计图面

- 空设计器的图面上应有一个水印，指示如何开始使用。

- 视图切换机制将遵循现有模式，如双击以打开代码编辑器，或允许与这两个窗格进行交互的文档窗口中的选项卡。

- 将元素添加到设计图面应通过工具箱完成，除非需要高度特定的工具窗口。

- 图面上的项将遵循一致的选择模型。

- 嵌入工具栏仅包含特定于文档的命令，而不包含 **保存** 等常见命令。

#### <a name="dialog-style-editors"></a>对话框样式编辑器

- 控件布局应遵循普通的对话框布局约定。

- 编辑器中的选项卡不应与文档选项卡的外观匹配，它们应与两个允许的内部选项卡样式之一匹配。

- 用户必须能够仅使用键盘与控件交互;通过激活编辑器并按 tab 键或使用标准的助记键来切换。

- 设计器应使用通用保存模型。 不应将整体的 "保存" 或 "提交" 按钮放置在表面上，尽管其他按钮可能适用。

#### <a name="model-designers"></a>模型设计器

- 空设计器的图面上应有一个水印，指示如何开始使用。

- 将元素添加到设计图面应通过工具箱完成。

- 图面上的项将遵循一致的选择模型。

- 嵌入工具栏仅包含特定于文档的命令，而不包含 **保存** 等常见命令。

- 图例可能出现在表面上，即指示或水印。

- 用户必须可以使用 " **工具" > "选项** " 页上的 "工具"、"共享字体和颜色" 页或特定于编辑器的工具来自定义字体/颜色的外观。

#### <a name="reports"></a>报表

- 报表通常只是信息信息，不参与保存模型。 但它们可能包含交互，如指向其他相关信息的链接或展开和折叠的部分。

- 图面上的大多数命令都应为超链接，而不是按钮。

- 布局应包括标题，并遵循标准报表布局准则。

#### <a name="dashboards"></a>仪表板

- 仪表板本身没有交互模型，但作为一种提供各种其他工具的方法。

- 它们不参与保存模型。

- 用户只有通过激活编辑器并按 tab 键或使用标准的助记键，才能使用键盘与控件进行交互。

## <a name="dialogs"></a><a name="BKMK_Dialogs"></a> 对话

### <a name="introduction"></a>简介
Visual Studio 中的对话通常应支持用户工作的一个离散单元，然后将其解除。

如果已确定需要对话框，可以按优先选择的顺序进行三个选择：

1. 将功能集成到 Visual Studio 中的某个共享对话框。

2. 使用在现有类似对话框中找到的模式创建自己的对话框。

3. 按照交互和布局准则创建新的对话框。

本部分介绍如何在 Visual Studio 工作流中选择正确的对话模式，以及如何在对话设计中选择通用约定。

### <a name="themes"></a>主题
Visual Studio 中的对话框采用以下两种基本样式之一：

#### <a name="standard-unthemed"></a>标准 (unthemed) 
大多数对话框都是标准实用工具对话框，应 unthemed。 不要重新对公共控件进行模板化或尝试创建风格的 "新式" 按钮或控件。 控件和 chrome 外观按照[标准 Windows 对话框的桌面交互指南](/windows/desktop/uxguide/win-dialog-box)。

#### <a name="themed"></a>主题
专业的 "签名" 对话框可能有主题。 主题对话框具有不同的外观，这也有一些与样式关联的特殊交互模式。 仅当对话框符合以下要求时才对其进行主题：

- 此对话框是通常情况下或由许多用户使用的常见体验，如 "**新建 Project** " 对话框 (。

- 此对话框包含突出的产品品牌元素 (例如，) **帐户设置** 对话框。

- 此对话框显示为包含其他主题对话框的较大流的组成部分， (例如，" **添加连接的服务** " 对话框) 。

- 此对话框是体验的重要部分，在提升或区分产品版本方面扮演战略角色。

创建主题对话框时，请使用适当的环境颜色，并遵循正确的布局和交互模式。  (参阅[Visual Studio 的布局](../../extensibility/ux-guidelines/layout-for-visual-studio.md)。 ) 

### <a name="dialog-design"></a>对话框设计
设计良好的对话框会考虑以下元素：

- 受支持的用户任务

- 对话框文本样式、语言和术语

- 控制选择和 UI 约定

- 视觉布局规范和控件对齐

- 键盘访问

#### <a name="content-organization"></a>内容组织
请考虑这种基本类型的对话框之间的差异：

- [简单对话框](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs) 在单个模式窗口中显示控件。 此演示可能包含复杂控件模式的变体，包括字段选取器或图标栏。

- 当一段 UI 包含多组控件时，[分层对话](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs)用于充分利用屏幕空间。 该对话框的分组通过选项卡控件、导航列表控件或按钮 "分层"，以便用户可以选择在任何给定时刻要查看的分组。

- [向导](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards) 可用于将用户的逻辑顺序定向到任务完成。 顺序面板中提供了一系列选项，有时会引入不同的工作流 ( "分支" ) 依赖于上一面板中所做的选择。

#### <a name="simple-dialogs"></a><a name="BKMK_SimpleDialogs"></a> 简单对话框
一个简单的对话框是在单个模式窗口中显示控件。 此演示可能包含复杂控件模式的变体，如字段选取器。 对于简单对话框，请遵循标准一般布局以及复杂控件分组所需的任何特定布局。

![>创建强名称密钥是 Visual Studio 中简单对话框的示例。](../../extensibility/ux-guidelines/media/0704-01_createstrongnamekey.png "0704-01_CreateStrongNameKey")<br />创建强名称密钥是 Visual Studio 中简单对话框的示例。

#### <a name="layered-dialogs"></a><a name="BKMK_LayeredDialogs"></a> 分层对话
分层对话框包含选项卡、仪表板和嵌入树。 当在一个 UI 中提供了多组控件时，这些控件用于最大化房地产。 分组是分层的，以便用户可以选择要在任何时候查看的分组。

在最简单的情况下，在分组之间切换的机制是选项卡控件。 有多种方法可供选择。 请参阅优先顺序和分层，了解如何选择最适合的样式。

" **工具 &gt; 选项** " 对话框是使用嵌入树的分层对话框的一个示例：

![工具 > 选项是 Visual Studio 中分层对话框的一个示例。](../../extensibility/ux-guidelines/media/0704-02_toolsoptions.png "0704-02_ToolsOptions")<br />工具 > 选项是 Visual Studio 中分层对话框的一个示例。

#### <a name="wizards"></a><a name="BKMK_Wizards"></a> 向导
向导可用于在任务完成过程中通过逻辑步骤顺序定向用户。 连续面板中提供了一系列选项，用户必须继续执行每个步骤，然后才能继续下一步。 有足够的默认值后，" **完成** " 按钮处于启用状态。

 模式向导用于以下任务：

- 包含分支，根据用户选择提供不同的路径

- 包含步骤之间的依赖关系，后续步骤依赖于前述步骤中的用户输入 (s) 

- 非常复杂，UI 应该用于说明每个步骤中提供的选项和可能的结果

- 是事务性的，在提交更改之前，需要一组步骤全部完成

### <a name="common-conventions"></a>常见约定
若要通过对话框实现最佳设计和功能，请在对话框大小、位置、标准、控件配置和对齐方式、UI 文本、标题栏、控件按钮和访问键上遵循这些约定。

有关特定于布局的准则，请参阅[Visual Studio 的布局](../../extensibility/ux-guidelines/layout-for-visual-studio.md)。

#### <a name="size"></a>大小
对话应适合于最小1024x768 屏幕分辨率，初始对话框大小不应超过900x700 像素。 可以调整对话框的大小，但这不是必需的。

有两个针对可调整大小的对话框的建议：

1. 最小大小是为对话框定义的，它将优化控件集而不进行剪辑，并调整以适应合理的本地化增长。

2. 用户缩放的大小在会话之间保持不变。 例如，如果用户将对话框缩放为150%，则随后启动对话框时将显示150%。

#### <a name="position"></a>位置
第一次启动时，对话框必须在 IDE 中居中显示。 不可调整大小的对话框的最后位置不需要保持，因此它们将在后续启动时居中显示。

对于可调整大小的对话框，应在后续启动时保留大小。 对于可以调整大小的模式对话框，位置不需要保持。 如果在 IDE 中居中显示它们，则在用户的显示配置发生更改时，可能会出现意外或不可用的情况。

对于可以重新定位的无模式对话框，应在后续启动时保留用户的位置，因为对话框可能经常用作较大工作流的组成部分。

当对话框必须生成其他对话框时，最顶部的对话框应从父级向右和向下移动，以便用户可以很容易地从父对话框导航到新位置。

#### <a name="modality"></a>模态
如果是模式，则表示用户需要先完成或取消对话框，然后才能继续。 由于模式对话框阻止用户与环境中的其他部分交互，因此功能的任务流应尽可能少地使用它们。 如果需要模式操作，Visual Studio 有多个共享对话框，您可以将功能集成到其中。 如果必须创建新对话框，请遵循具有类似功能的现有对话框的交互模式。

当用户需要同时执行两个活动（如在编写新代码时 **查找** 和 **替换** ）时，该对话框应为无模式对话框，以便用户可以轻松地在它们之间切换。 Visual Studio 通常将工具窗口用于此类支持的链接任务。

#### <a name="control-configuration"></a>控件配置
与 Visual Studio 中实现相同操作的现有控件配置保持一致。

#### <a name="title-bars"></a>标题栏

- 标题栏中的文本必须反映启动它的命令的名称。

- 对话框标题栏中不应使用图标。 如果系统需要一个，请使用 Visual Studio 徽标。

- 对话框不应具有最小化或最大化按钮。

- 已不推荐使用标题栏中的 "帮助" 按钮。 不要将它们添加到新对话框中。 如果它们存在，则应启动在概念上与该任务相关的帮助主题。

  ![Visual Studio 对话框中标题栏的准则规范](../../extensibility/ux-guidelines/media/0704-03_titlebarspecs.png "0704-03_TitleBarSpecs")<br />Visual Studio 对话框中标题栏的准则规范

#### <a name="control-buttons"></a>控件按钮
通常，在对话框的右下角， **"确定"、"****取消**" 和 "**帮助**" 按钮应水平排列。 如果对话框底部有多个其他按钮，则允许使用备用垂直堆栈，这会显示与控件按钮的视觉混淆。

![Visual Studio 对话框中控件按钮的可接受配置](../../extensibility/ux-guidelines/media/0704-04_controlbuttonconfig.png "0704-04_ControlButtonConfig")<br />Visual Studio 对话框中控件按钮的可接受配置

此对话框必须包含默认的控件按钮。 若要确定要使用的最佳命令作为默认设置，请从以下选项中选择 (按) 优先级顺序列出：

- 选择最安全和最安全的命令作为默认命令。 这意味着选择最有可能阻止数据丢失的命令，避免意外的系统访问。

- 如果数据丢失和安全不是因素，请根据便利性选择默认命令。 如果此对话框支持频繁任务或重复性任务，则最可能的命令作为默认设置将改进用户的工作流。

避免为默认命令选择永久破坏性操作。 如果出现此类命令，请改为选择更安全的命令。

#### <a name="access-keys"></a>访问密钥
不要将访问键用于 **"确定"、"****取消**" 或 "**帮助**" 按钮。 默认情况下，这些按钮映射到快捷键：

| 按钮名称 | 键盘快捷键 |
| --- | --- |
| 确定 | Enter |
| 取消 | Esc |
| 帮助 | F1 |

#### <a name="imagery"></a>图像
在对话框中尽量少使用图像。 不要在对话框中使用大图标只是为了使用空间。 仅在将邮件传达给用户（如警告图标或状态动画）时，才使用图像。

### <a name="prioritizing-and-layering"></a><a name="BKMK_PrioritizingAndLayering"></a> 确定优先级和分层

#### <a name="prioritizing-your-ui"></a>确定 UI 的优先级
可能有必要将某些 UI 元素引入 forefront，并将更高级的行为和选项 (包括) 到对话框中的模糊命令。 为 forefront 提供常用功能，通过为其腾出空间，并使其在用户界面中默认可见，并在显示对话框时使用文本标签。

#### <a name="layering-your-ui"></a>层叠 UI
如果已确定对话框是必需的，但要向用户显示的相关功能超出了可在简单对话框中显示的内容，则需要对 UI 进行分层。 Visual Studio 使用的最常见的分层方法是选项卡、走廊或仪表板。 在某些情况下，可以展开和折叠的区域可能适用。 在 Visual Studio 中，通常不建议使用自适应 UI。

通过类似于选项卡的控件，分层 UI 的不同方法有一些优点和缺点。 查看以下列表，确保选择适合你的情况的分层方法。

##### <a name="tabbing"></a>Tab 键次序

| 切换机制 | 优点和合适的用途 | 缺点和不当使用 |
| --- | --- | --- |
| Tab 控件 | 逻辑分组对话框页面到相关集<br /><br />在对话框中的相关控件) 页上，在对话框中包含的列数不超过五个 (或制表符<br /><br />选项卡标签必须为 short：一个或两个单词，可轻松地识别内容<br /><br />常见系统对话框样式<br /><br />示例： **文件资源管理器 &gt; 项属性** | 可能很难进行描述性简短标签<br /><br />通常不会在一个对话框中缩放过去的五个选项卡<br /><br />如果一个行的选项卡太多 (使用替代分层技术) <br /><br />不可扩展 |
| 边栏导航 | 可以容纳超过选项卡的多个类别的简单切换设备<br /><br />不 (层次结构的类别的简单列表) <br /><br />可扩展<br /><br />示例： **自定义 ... &gt; 添加命令** | 如果少于三个组，则不能使用水平空间。<br /><br />任务可能更适合下拉 |
| 树控件 | 允许无限制类别<br /><br />允许对类别进行分组和/或层次结构<br /><br />可扩展<br /><br />示例： **工具 &gt; 选项** | 高度嵌套的层次结构可能导致过多的水平滚动<br /><br />Visual Studio 具有 overabundance 的树视图 |
| 向导 | 通过基于任务的顺序步骤指导用户完成任务完成：向导表示高级任务，而各个面板代表完成总体任务所需的子任务<br /><br />当任务跨越 Ui 边界时非常有用，因为当用户需要使用多个编辑器和工具窗口完成任务时，<br /><br />当任务需要分支时有用<br /><br />当任务包含步骤间的依赖关系时有用<br /><br />在一个对话框中显示多个具有一个决策分叉的类似任务时，此方法非常有用，可减少不同相似对话框的数量 | 不适用于不需要顺序工作流的任何任务<br /><br />如果向导执行的操作过多，可能会使用户感到不知所措和混淆<br /><br />向导在本质上是有限的屏幕 |

##### <a name="hallways-or-dashboards"></a>走廊或仪表板
走廊和仪表板是对话框或面板，它们充当其他对话框和窗口的启动点。 设计良好的 "走廊" 立即只显示最常见的选项、命令和设置，使用户能够轻松完成常见任务。 与现实世界走廊提供两侧来访问他们后面的聊天室，这里的常见 UI 会被收集到单独的 "房间" 中 (通常其他对话框) 可从主要走廊访问的相关功能。

或者，在单个集合中提供所有可用功能的 UI，而不是将不太常见的功能重构到不同的位置，只是一个仪表板。

![用于在 Outlook 中公开附加 UI 的走廊概念](../../extensibility/ux-guidelines/media/0704-08_hallway.png "0704-08_Hallway")<br />用于在 Outlook 中公开附加 UI 的走廊概念

##### <a name="adaptive-ui"></a>自适应 UI
显示或隐藏基于使用情况或用户的自报告体验的 UI 是在隐藏其他部分的同时提供必要 UI 的另一种方法。 不建议在 Visual Studio 中这样做，因为用于决定何时显示或隐藏 UI 的算法可能比较棘手，并且对于某些事例集，规则始终会出现错误。

## <a name="projects"></a><a name="BKMK_Projects"></a> 投射

### <a name="projects-in-the-solution-explorer"></a>解决方案资源管理器中的项目
大多数项目归类为基于引用、基于目录或混合。 解决方案资源管理器中同时支持所有这三种类型的项目。 使用项目的用户体验的根本发生在此窗口内。 尽管不同的项目节点是引用、目录或混合模式类型项目，但在拆分为特定于项目的用户模式之前，还应将常见交互模式应用为起点。

项目应始终：

- 支持添加项目文件夹来组织项目内容的功能

- 为项目持久性维护一致的模型

项目还应为以下各内容维护一致的交互模型：

- 删除项目项

- 保存文档

- Project 属性编辑

- 在替代视图中编辑项目

- 拖放操作

### <a name="drag-and-drop-interaction-model"></a>拖放交互模型
项目通常会将自身分类为基于引用的 (只能保留对存储) 中的项目项的引用，基于目录的 (能够仅保存物理存储在项目层次结构中的项目项) ，或混合 (能够将引用或物理项保存) 。 IDE 在 **解决方案资源管理器** 中同时容纳所有三种类型的项目。

从拖放角度来看，以下特性应该适用于 **解决方案资源管理器** 中的每种类型的项目：

- **基于引用的项目：** 关键在于，项目是围绕存储中的项的引用进行拖动。 当基于引用的项目用作移动操作的源时，它只应从项目中删除对该项的引用。 不应实际从硬盘中删除该项。 当基于引用的项目作为 move (或 copy) 操作的目标时，它应添加对原始源项的引用，而无需创建该项的私有副本。

- **基于目录的项目：** 从拖放的角度来看，项目在物理项（而不是引用）上拖动。 当基于目录的项目用作移动操作的源时，它应最终将物理项目从硬盘删除，并将其从项目中删除。 当基于目录的项目作为 move (或 copy) 操作的目标时，它应在其目标位置生成源项的副本。

- **混合目标项目：** 从拖放的角度来看，这种类型的项目的行为基于要拖动的项的性质 (引用存储中的项或) 项本身。 上文介绍了引用和物理项的正确行为。

如果 **解决方案资源管理器** 中只有一种类型的项目，则拖放操作非常简单。 由于每个项目系统都能够定义其自己的拖放行为，因此， (基于 Windows 资源管理器拖放行为的某些指导原则) 应遵循此原则，以确保可预测的用户体验：

- 当按住 Ctrl 键或 Shift 键时， **解决方案资源管理器** (中未修改的拖动操作) 应导致移动操作。

- Shift + 拖动操作还应导致移动操作。

- 按住 Ctrl 键的同时操作将导致复制操作。

- 基于引用和混合的项目系统支持添加链接 (或引用) 到源项的概念。 当这些项目是拖放操作的目标时 (在按住 **Ctrl + Shift**) 时，它应导致对要添加到项目中的项的引用。

并非所有拖放操作都适用于基于引用、基于目录和混合项目的组合。 具体而言，假设允许在基于目录的源项目与基于引用的目标项目之间进行移动操作是有问题的，因为基于源目录的项目在移动完成后必须删除源项。 然后，基于目标引用的项目最终将引用已删除的项。

它还会误导您在这些类型的项目之间允许复制操作，因为基于目标引用的项目不应创建源项的独立副本。 同样，不应允许使用 Ctrl + Shift 拖动到基于目录的目标项目，因为基于目录的项目无法保留引用。 在不支持拖放操作的情况下，IDE 应禁止放置，并向用户显示 "不删除" 光标 (如下) 中的指针表中所示。

为了正确实现拖放行为，拖动的源项目需要将其性质传达给目标项目。  (例如，是基于引用还是基于目录的？ ) 此信息由源提供的剪贴板格式指示。 作为拖动 (或剪贴板复制操作的源) 项目应提供 `CF_VSREFPROJECTITEMS` 或 `CF_VSSTGPROJECTITEMS` 分别提供，具体取决于该项目是基于引用还是基于目录。 这两种格式具有相同的数据内容，这与 Windows 格式类似， `CF_HDROP` 不同之处在于字符串列表，而不是文件名，而是 `NULL` 从) 返回的字符串的双终止列表， `Projref` (`IVsSolution::GetProjrefOfItem` `::GetProjrefOfProject` 。

作为) 的 drop (或剪贴板粘贴操作的目标，项目应同时接受 `CF_VSREFPROJECTITEMS` 和 `CF_VSSTGPROJECTITEMS` ，尽管拖放操作的确切处理因目标项目和源项目的性质而异。 源项目根据其提供还是来声明其本质 `CF_VSREFPROJECTITEMS` `CF_VSSTGPROJECTITEMS` 。 Drop 的目标理解自己的性质，因此具有足够的信息来决定是否应执行移动、复制或链接。 用户还可以通过按 ctrl、Shift 或同时按 Ctrl 键和 Shift 键来修改应执行的拖放操作。 放置目标正确指示将在其和方法中提前执行的操作非常重要 `DragEnter` `DragOver` 。 **解决方案资源管理器** 会自动知道源项目和目标项目是否为同一个项目。

在 Visual Studio (的实例间拖动项目项，例如，不支持从一个 devenv.exe 实例到另一个) 。 **解决方案资源管理器** 也直接禁用了此。

用户应始终能够通过以下方式确定拖放操作的效果：选择一个项，将其拖至目标位置，然后观察在该项被删除之前出现的以下鼠标指针：

| 鼠标指针 | 命令 | 说明 |
| :---: | --- | --- |
| ![鼠标“不放下”图标](../../extensibility/ux-guidelines/media/0706-01_mousenodrop.png "0706-01_MouseNoDrop") | 不删除 | 无法将项拖放到指定位置。 |
| ![鼠标“复制”图标](../../extensibility/ux-guidelines/media/0706-02_mousecopy.png "0706-02_MouseCopy") | 复制 | 项将被复制到目标位置。 |
| ![鼠标“移动”图标](../../extensibility/ux-guidelines/media/0706-03_mousemove.png "0706-03_MouseMove") | 移动 | 项将移动到目标位置。 |
| ![鼠标“添加引用”图标](../../extensibility/ux-guidelines/media/0706-04_mouseaddref.png "0706-04_MouseAddRef") | 添加引用 | 对所选项的引用将添加到目标位置。 |

#### <a name="reference-based-projects"></a>基于引用的项目
 下表汇总了拖放 (以及根据基于引用的目标项目按下的源项和修改键的性质，应执行的剪切/复制/粘贴) 操作：

| 修饰符 | 类别 | 源项：引用/链接 | 源项：物理项或文件系统 (`CF_HDROP`)  |
| --- | --- | --- | --- |
| No 修饰符 | 操作 | 移动 | 链接 |
| No 修饰符 | 目标 | 添加对原始项的引用 | 添加对原始项的引用 |
| No 修饰符 | 源 | 删除对原始项的引用 | 保留原始项 |
| No 修饰符 | 结果 | `DROPEFFECT_MOVE` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | `DROPEFFECT_LINK` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 |
| Shift + 拖动 | 操作 | 移动 | 不删除 |
| Shift + 拖动 | 目标 | 添加对原始项的引用 | 不删除 |
| Shift + 拖动 | 源 | 删除对原始项的引用 | 不删除 |
| Shift + 拖动 | 结果 | `DROPEFFECT_MOVE` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | 不删除 |
| Ctrl + 拖动 | 操作 | 复制 | 不删除 |
| Ctrl + 拖动 | 目标 | 添加对原始项的引用 | 不删除 |
| Ctrl + 拖动 | 源 | 保留对原始项的引用 | 不删除 |
| Ctrl + 拖动 | 结果 | `DROPEFFECT_COPY` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | 不删除 |
| Ctrl + Shift + 拖动 | 操作 | 链接 | 链接 |
| Ctrl + Shift + 拖动 | 目标 | 添加对原始项的引用 | 添加对原始项的引用 |
| Ctrl + Shift + 拖动 | 源 | 保留对原始项的引用 | 保留原始项 |
| Ctrl + Shift + 拖动 | 结果 | `DROPEFFECT_LINK` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 | `DROPEFFECT_LINK` 作为中的操作返回 `::Drop` ，项仍保留在存储中的原始位置 |
| Ctrl + Shift + 拖动 | 备注 | 与 Windows 资源管理器中快捷方式的拖放行为相同。 ||
| 剪切/粘贴 | 操作 | 移动 | 链接 |
| 剪切/粘贴 | 目标 | 添加对原始项的引用 | 添加对原始项的引用 |
| 剪切/粘贴 | 源 | 保留对原始项的引用|保留原始项 |
| 剪切/粘贴 | 结果 | 项目保留在存储中的原始位置 | 项目保留在存储中的原始位置 |
| 复制/粘贴 | 操作 | 复制 | 链接 |
| 复制/粘贴 | 源 | 添加对原始项的引用 | 添加对原始项的引用 |
| 复制/粘贴 | 结果 | 保留对原始项的引用 | 保留原始项 |
| 复制/粘贴 | 操作 | 项保留在存储中的原始位置 | 项保留在存储中的原始位置 |

#### <a name="directory-based-projects"></a>基于目录的项目
下表汇总了拖放 (以及应该根据为基于目录的目标项目按下的源项和修饰符键的性质执行的剪切/复制/粘贴) 操作：

| 修饰符 | 类别 | 源项：引用/链接 | 源项：物理项或文件系统 `CF_HDROP` ()  |
|-----------------|----------| - | - |
| 无修饰符 | 操作 | 移动 | 移动 |
| 无修饰符 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| 无修饰符 | 源 | 删除对原始项的引用 | 删除对原始项的引用 |
| Shift+拖动 | 操作 | 移动 | 移动 |
| Shift+拖动 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| Shift+拖动 | 源 | 删除对原始项的引用 | 从原始位置删除项 |
| Shift+拖动 | 结果 | `DROPEFFECT_MOVE` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | `DROPEFFECT_MOVE` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 |
| Ctrl+拖动 | 操作 | 复制 | 复制 |
| Ctrl+拖动 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| Ctrl+拖动 | 源 | 保留对原始项的引用 | 保留对原始项的引用 |
| Ctrl+拖动 | 结果 | `DROPEFFECT_COPY` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | `DROPEFFECT_COPY` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 |
| Ctrl+Shift+拖动 | | 无删除 | 无删除 |
| 剪切/粘贴 | 操作 | 移动 | 移动 |
| 剪切/粘贴 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| 剪切/粘贴 | 源 | 删除对原始项的引用 | 从原始位置删除项 |
| 剪切/粘贴 | 结果 | 项保留在存储中的原始位置 | 从存储中的原始位置删除项 |
| 复制/粘贴 | 操作 | 复制 | 复制 |
| 复制/粘贴 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| 复制/粘贴 | 源 | 保留原始项 | 保留原始项 |
| 复制/粘贴 | 结果 | 项保留在存储中的原始位置 | 项保留在存储中的原始位置 |

#### <a name="mixed-target-projects"></a>混合目标项目
下表汇总了拖放 (以及应基于为混合目标项目按下的源项和修改键的性质执行的剪切/复制/粘贴) 操作：

| 修饰符 | 类别 | 源项：引用/链接 | 源项：物理项或文件系统 `CF_HDROP` ()  |
| --- | --- | --- | --- |
| 无修饰符 | 操作 | 移动 | 移动 |
| 无修饰符 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| 无修饰符 | 源 | 删除对原始项的引用 | 删除对原始项的引用 |
| 无修饰符 | 结果 | `DROPEFFECT_ MOVE` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | `DROPEFFECT_ MOVE` 作为 操作返回， `::Drop` 项将从存储中的原始位置中删除 |
| Shift+拖动 | 操作 | 移动 | 移动 |
| Shift+拖动 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| Shift+拖动 | 源 | 删除对原始项的引用 | 从原始位置删除项 |
| Shift+拖动 | 结果 | `DROPEFFECT_ MOVE` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | `DROPEFFECT_ MOVE` 作为 操作返回， `::Drop` 项将从存储中的原始位置中删除 |
| Ctrl+拖动 | 操作 | 复制 | 复制 |
| Ctrl+拖动 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| Ctrl+拖动 | 源 | 保留对原始项的引用 | 保留原始项 |
| Ctrl+拖动 | 结果 | `DROPEFFECT_ COPY` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | `DROPEFFECT_ COPY` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 |
| Ctrl+Shift+拖动 | 操作 | 链接 | 链接 |
| Ctrl+Shift+拖动 | 目标 | 添加对原始项的引用 | 添加对原始源项的引用 |
| Ctrl+Shift+拖动 | 源 | 保留对原始项的引用 | 保留原始项 |
| Ctrl+Shift+拖动 | 结果 | `DROPEFFECT_ LINK` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 | `DROPEFFECT_ LINK` 作为 操作返回， `::Drop` 项保留在存储中的原始位置 |
| 剪切/粘贴 | 操作 | 移动 | 移动 |
| 剪切/粘贴 | 目标 | 将项复制到目标位置 | 将项复制到目标位置 |
| 剪切/粘贴 | 源 | 删除对原始项的引用 | 从原始位置删除项 |
| 剪切/粘贴 | 结果 | 项保留在存储中的原始位置 | 从存储中的原始位置删除项 |
| 复制/粘贴 | 操作 | 复制 | 复制 |
| 复制/粘贴 | 目标 | 添加对原始项的引用 | 将项复制到目标位置 |
| 复制/粘贴 | 源 | 保留原始项 | 保留原始项 |
| 复制/粘贴 | 结果 | 项保留在存储中的原始位置 | 项目保留在存储中的原始位置 |

在 **解决方案资源管理器** 中实现拖动时，应考虑这些详细信息：

- 设计多选方案。

- 文件名称 (完整路径) 在目标项目中必须是唯一的，否则不允许放置。

- 文件夹名称必须是唯一的， (不区分大小写的) 。

- 在拖动时打开或关闭的文件之间存在行为差异 (未在上述方案中提到) 。

- 顶级文件的行为与文件夹中的文件略有不同。

要注意的另一个问题是如何处理已打开设计器或编辑器的项的移动操作。 预期行为如下 (这适用于所有项目类型) ：

1. 如果打开的编辑器/设计器没有任何未保存的更改，则编辑器/设计器窗口应以静默方式关闭。

2. 如果打开的编辑器/设计器确实有未保存的更改，则拖动的源应等待放置操作，然后要求用户在关闭窗口之前保存打开的文档中未提交的更改，并提示如下：

    ```
    ==========================================================
         One or more open documents have unsaved changes.
    Do you want to save uncommitted changes before proceeding?
                      [Yes]  [No]  [Cancel]
    ==========================================================
    ```

这为用户提供了在目标创建副本之前保存正在进行的工作的机会。 添加了一种新方法 `IVsHierarchyDropDataSource2::OnBeforeDropNotify` 来启用此处理。

然后，目标将复制项在存储中的状态，如果用户选择 " **无** ") ，则不在编辑器中包含未保存的更改 (不包含未保存的更改。 目标完成其复制 (`IVsHierarchyDropDataSource::Drop`) 后，就有机会在) 中完成移动操作 (删除部分 `IVsHierarchyDropDataSource::OnDropNotify` 。

具有未保存更改的任何编辑器都应保持打开状态。 对于包含未保存更改的文档，这意味着将执行移动操作的复制部分，但会中止删除部分。 在多选方案中，当用户选择 " **否**" 时，不应关闭或删除那些具有未保存更改的文档，而不保存更改的文档应关闭并删除。
