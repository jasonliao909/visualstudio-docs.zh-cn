---
title: CA2117:APTCA 类型应只扩展 APTCA 基类型
description: 具有 System.Security.AllowPartiallyTrustedCallersAttribute 属性的程序集中的公共或受保护类型继承自在没有 属性的程序集中声明的类型。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA2117
- AptcaTypesShouldOnlyExtendAptcaBaseTypes
helpviewer_keywords:
- AptcaTypesShouldOnlyExtendAptcaBaseTypes
- CA2117
ms.assetid: c505b586-2f1e-47cb-98ee-a5afcbeda70f
author: mikejo5000
ms.author: mikejo
manager: jmartens
ms.technology: vs-ide-code-analysis
ms.workload:
- multiple
ms.openlocfilehash: e007677df433fe3b545742070ab902000b5eab805c592a4ab22afc0629c56cf3
ms.sourcegitcommit: c72b2f603e1eb3a4157f00926df2e263831ea472
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/12/2021
ms.locfileid: "121455785"
---
# <a name="ca2117-aptca-types-should-only-extend-aptca-base-types"></a>CA2117:APTCA 类型应只扩展 APTCA 基类型

|项|“值”|
|-|-|
|RuleId|CA2117|
|类别|Microsoft.Security|
|重大更改|重大|

## <a name="cause"></a>原因
具有 属性的程序集中的公共或受保护类型继承自在不包含 特性的程序集中 <xref:System.Security.AllowPartiallyTrustedCallersAttribute?displayProperty=fullName> 声明的类型。

> [!NOTE]
> 此规则已被弃用。 有关详细信息，请参阅已 [弃用的规则](fxcop-unported-deprecated-rules.md)。

## <a name="rule-description"></a>规则说明

默认情况下，具有强名称的程序集中的公共或受保护类型由 [InheritanceDemand](xref:System.Security.Permissions.SecurityAction#System_Security_Permissions_SecurityAction_InheritanceDemand) 隐式保护，以完全信任。 使用 APTCA 属性标记 (<xref:System.Security.AllowPartiallyTrustedCallersAttribute> 强) 程序集没有此保护。 属性禁用继承要求。 没有继承需求的程序集中声明的公开类型由没有完全信任的类型继承。

当完全受信任的程序集上存在 APTCA 属性，并且程序集中的类型继承自不允许部分受信任的调用方的类型时，可能会受到安全漏洞攻击。 如果两种类型 和 满足以下条件，恶意调用方可以使用 类型绕过保护 的隐式 `T1` `T2` `T1` 完全信任继承要求 `T2` ：

- `T1` 是在具有 APTCA 属性的完全受信任的程序集中声明的公共类型。

- `T1` 从其程序集外部 `T2` 的类型继承。

- `T2`的程序集没有 APTCA 属性，因此，不应由部分受信任的程序集中的类型继承。

部分受信任的类型可以从 `X` 继承， `T1` 这使它可以访问 中声明的继承成员 `T2` 。 由于 没有 APTCA 属性，因此其直接派生 () 必须满足完全信任的继承要求;具有完全信任， `T2` `T1` `T1` 因此满足此检查。 安全风险是 ，因为 不参与满足防止不受信任的子类的继承 `X` `T2` 需求。 因此，具有 APTCA 属性的类型不得扩展没有 属性的类型。

另一个安全问题（可能是更常见的一个问题）是派生类型 () 可以通过程序员错误公开类型中需要完全信任的受保护成员 `T1` `T2` () 。 发生这种公开时，不受信任的调用方将获取对应仅对完全受信任的类型可用的信息的访问权限。

## <a name="how-to-fix-violations"></a>如何解决冲突

如果冲突报告的类型位于不需要 APTCA 属性的程序集中，请将其删除。

如果需要 APTCA 属性，请为类型添加完全信任的继承要求。 继承需求防止不受信任的类型继承。

通过将 APTCA 属性添加到冲突报告的基类型的程序集，可以修复冲突。 如果不首先对程序集中所有代码和依赖于程序集的所有代码进行密集型安全检查，请不要这样做。

## <a name="when-to-suppress-warnings"></a>何时禁止显示警告

若要安全地禁止显示此规则的警告，必须确保类型公开的受保护成员不直接或间接地允许不受信任的调用方访问以破坏性方式使用的敏感信息、操作或资源。

## <a name="example"></a>示例

以下示例使用两个程序集和测试应用程序来说明此规则检测到的安全漏洞。 第一个程序集没有 APTCA 属性，并且不应由部分受信任的类型继承 (在上一个讨论主题中由 `T2` 表示) 。

:::code language="csharp" source="../snippets/csharp/VS_Snippets_CodeAnalysis/FxCop.Security.NoAptcaInherit/cs/FxCop.Security.NoAptcaInherit.cs" id="Snippet1":::

在上一个讨论中由 表示的第二个程序集是完全受信任的，并允许 `T1` 部分受信任的调用方。

:::code language="csharp" source="../snippets/csharp/VS_Snippets_CodeAnalysis/FxCop.Security.YesAptcaInherit/cs/FxCop.Security.YesAptcaInherit.cs" id="Snippet1":::

在上一个讨论中由 `X` 表示的测试类型位于部分受信任的程序集中。

:::code language="csharp" source="../snippets/csharp/VS_Snippets_CodeAnalysis/FxCop.Security.TestAptcaInherit/cs/FxCop.Security.TestAptcaInherit.cs" id="Snippet1":::

该示例产生下面的输出：

```txt
Meet at the shady glen 2/22/2003 12:00:00 AM!
From Test: sunny meadow
Meet at the sunny meadow 2/22/2003 12:00:00 AM!
```

## <a name="related-rules"></a>相关规则

[CA2116:APTCA 方法应只调用 APTCA 方法](../code-quality/ca2116.md)

## <a name="see-also"></a>另请参阅

- [安全编码准则](/dotnet/standard/security/secure-coding-guidelines)
- [通过部分受信任的代码使用库](/dotnet/framework/misc/using-libraries-from-partially-trusted-code)
