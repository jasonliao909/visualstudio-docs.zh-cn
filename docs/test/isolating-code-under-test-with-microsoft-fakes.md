---
title: 用 Microsoft Fakes 隔离测试代码
description: 了解 Microsoft Fakes 如何通过将应用程序的其余部分替换为存根或填充码来帮助隔离要测试的代码。
ms.custom: SEO-VS-2020, devdivchpfy22
ms.date: 02/02/2022
ms.topic: how-to
ms.author: mikejo
manager: jmartens
ms.technology: vs-ide-test
ms.workload:
- multiple
author: mikejo5000
dev_langs:
- VB
- CSharp
ms.openlocfilehash: 23940edd4bdcbc16a9318fd6020093ef58b10303
ms.sourcegitcommit: 23b0ef3815833426933ff6491271034658683f9d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/02/2022
ms.locfileid: "137983801"
---
# <a name="isolate-code-under-test-with-microsoft-fakes"></a>用 Microsoft Fakes 隔离测试代码

Microsoft Fakes将应用程序的其他部分替换为存根或填充码，帮助隔离 *要测试**的代码*。 存根和填充码是受测试控制的小段代码。 通过隔离接受测试的代码，你将会知道，如果测试失败，原因就在这里而不是其他地方。 存根和填充码还允许测试代码，即使应用程序的其他部分尚未工作。

Fakes 有两种风格：

- [存根](#get-started-with-stubs)将类替换为可实现同一接口的小型替代项。  若要使用存根，你在设计应用程序时必须让每个组件仅依赖接口，而不依赖其他组件。 （“组件”是指一个类或一起开发和更新的一组类，通常包含在一个程序集中。）

- [填充](#get-started-with-shims)码在运行时修改应用程序的编译代码，以便运行测试提供的填充码代码，而不是进行指定的方法调用。 填充码可用于替换对无法修改的程序集（如 .NET 程序集）的调用。

    ![Fakes 将替换其他组件](../test/media/fakes-2.png)

**要求**

- Visual Studio Enterprise
- .NET Framework 项目
::: moniker range=">=vs-2019"
- .NET Core、.NET 5.0 或更高版本以及 SDK 样式的项目支持在 Visual Studio 2019 Update 6 中预览，在 Update 8 中默认启用。 有关详细信息，请参阅[适用于 .NET Core 和 SDK 样式项目的 Microsoft Fakes](/visualstudio/releases/2019/release-notes#microsoft-fakes-for-net-core-and-sdk-style-projects)。
::: moniker-end

> [!NOTE]
> 使用 Visual Studio 分析不适用于使用 Microsoft Fakes。

## <a name="choose-between-stub-and-shim-types"></a>在存根和填充码类型之间进行选择

通常，你将 Visual Studio 项目视为一个组件，这是因为你同时开发和更新这些类。 对于该项目对你的解决方案中的其他项目所作的调用或对该项目引用的其他程序集所作的调用，应考虑使用存根和填充码。

可以将存根用于解决方案中的Visual Studio，并使用填充码来调用其他引用的程序集。 这是因为，在你自己的解决方案中，最佳做法是按存根所需的方式定义接口来分离组件。 但是，外部程序集 *System.dll* 通常未提供单独的接口定义，因此必须改为使用填充码。

其他需要注意的事项还有：

**性能。** 填充码运行速度较慢，因为它们在运行时重写代码。 存根没有这种性能开销，并且速度与虚拟方法的速度一样快。

**静态方法和密封类型方法。** 你只能使用存根实现接口。 因此，存根类型不能用于静态方法、非虚拟方法、密封虚拟方法、密封类型中的方法等。

**内部类型。** 存根和填充码都可用于可通过程序集特性 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 访问的内部类型。

**私有方法。** 如果方法签名中的所有类型都是可见的，则填充码可替换对私有方法的调用。 存根只能替换可见方法。

**接口和抽象方法。** 存根提供了可用于测试的接口和抽象方法的实现。 填充码无法检测接口和抽象方法，因为它们没有方法体。

建议使用存根类型来隔离代码库中的依赖项。 可以通过隐藏接口后面的组件执行此操作。 可以使用填充码类型与不提供可测试 API 的第三方组件隔离。

## <a name="get-started-with-stubs"></a>存根入门

有关更详细的说明，请参阅[使用存根隔离应用的各个部分以供单元测试使用](../test/using-stubs-to-isolate-parts-of-your-application-from-each-other-for-unit-testing.md)。

1. **注入接口**

     若要使用存根，必须编写要测试的代码，使代码不会显式提及应用程序的另一个组件中的类。 “组件”是指一个类或一起开发和更新的多个类，通常包含在一个 Visual Studio 项目中。 变量和参数应该通过使用接口进行声明，其他组件的实例应该通过工厂传入或创建。 例如，如果 StockFeed 是应用程序的另一个组件中的类，则这被视为错误：

     `return (new StockFeed()).GetSharePrice("COOO"); // Bad`

     相反，可以定义一个接口，该接口可通过其他组件实现，也可以由存根实现，以便进行测试：

    ```csharp
    public int GetContosoPrice(IStockFeed feed) => feed.GetSharePrice("COOO");
    ```

    ```vb
    Public Function GetContosoPrice(feed As IStockFeed) As Integer
     Return feed.GetSharePrice("COOO")
    End Function

    ```

2. **添加 Fakes 程序集**

   1. 在“解决方案资源管理器”中： 
       - 对于旧版 .NET Framework 项目（非 SDK 样式），展开单元测试项目的“引用”节点。
       ::: moniker range=">=vs-2019"
       - 对于面向 .NET Framework、.NET Core 或 .NET 5.0 或更高版本的 SDK 样式项目，请展开"依赖项"节点，在"程序集"、"项目"或"包"下找到要虚设的 **程序集**。 
       ::: moniker-end
       - 如果使用的是 Visual Basic，请选择“解决方案资源管理器”工具栏中的“显示所有文件”，以查看“引用”节点。
   2. 选择包含要为其创建填充码的类定义的程序集。 例如，如果要填充 DateTime，请选择 System.dll   。

   3. 在快捷菜单上，选择"**添加Fakes程序集"**。

3. 在测试中，构建存根的实例并为存根的方法提供代码：

    ```csharp
    [TestClass]
    class TestStockAnalyzer
    {
        [TestMethod]
        public void TestContosoStockPrice()
        {
          // Arrange:

            // Create the fake stockFeed:
            IStockFeed stockFeed =
                 new StockAnalysis.Fakes.StubIStockFeed() // Generated by Fakes.
                     {
                         // Define each method:
                         // Name is original name + parameter types:
                         GetSharePriceString = (company) => { return 1234; }
                     };

            // In the completed application, stockFeed would be a real one:
            var componentUnderTest = new StockAnalyzer(stockFeed);

          // Act:
            int actualValue = componentUnderTest.GetContosoPrice();

          // Assert:
            Assert.AreEqual(1234, actualValue);
        }
        ...
    }
    ```

    ```vb
    <TestClass()> _
    Class TestStockAnalyzer

        <TestMethod()> _
        Public Sub TestContosoStockPrice()
            ' Arrange:
            ' Create the fake stockFeed:
            Dim stockFeed As New StockAnalysis.Fakes.StubIStockFeed
            With stockFeed
                .GetSharePriceString = Function(company)
                                           Return 1234
                                       End Function
            End With
            ' In the completed application, stockFeed would be a real one:
            Dim componentUnderTest As New StockAnalyzer(stockFeed)
            ' Act:
            Dim actualValue As Integer = componentUnderTest.GetContosoPrice
            ' Assert:
            Assert.AreEqual(1234, actualValue)
        End Sub
    End Class

    ```

    此处最为神奇的就是类 `StubIStockFeed`。 对于所引用程序集中的每个接口，Microsoft Fakes 机制将生成一个存根类。 存根类的名称派生自接口的名称，前缀为“`Fakes.Stub`”，并且在名称后面追加了参数类型名称。

    另外，还会为属性的 getter 和 setter、事件和泛型方法生成存根。 有关详细信息，请参阅[使用存根隔离应用的各个部分以供单元测试使用](../test/using-stubs-to-isolate-parts-of-your-application-from-each-other-for-unit-testing.md)。

## <a name="get-started-with-shims"></a>填充码入门

（有关更详细的说明，请参阅[使用填充码将应用与其他程序集相隔离以供单元测试使用](../test/using-shims-to-isolate-your-application-from-other-assemblies-for-unit-testing.md)。）

假定你的组件包含对 `DateTime.Now` 的调用：

```csharp
// Code under test:
    public int GetTheCurrentYear()
    {
       return DateTime.Now.Year;
    }
```

在测试过程中，你希望填充 `Now` 属性，因为每次调用时实际版本都会返回不同的值，从而造成了不便。

若要使用填充码，不必修改应用程序代码或以特定方式编写它。

1. **添加 Fakes 程序集**

     在解决方案资源管理器中，打开单元测试项目的引用，然后选择对包含要虚设的方法的程序集的引用。 在此示例中，`DateTime` 类位于 *System.dll* 中。  若要查看项目引用Visual Basic，请选择"**显示所有文件"**。

     选择 **"添加Fakes程序集"**。

2. **在 ShimsContext 中插入填充码**

    ```csharp
    [TestClass]
    public class TestClass1
    {
            [TestMethod]
            public void TestCurrentYear()
            {
                int fixedYear = 2000;

                // Shims can be used only in a ShimsContext:
                using (ShimsContext.Create())
                {
                  // Arrange:
                    // Shim DateTime.Now to return a fixed date:
                    System.Fakes.ShimDateTime.NowGet =
                    () =>
                    { return new DateTime(fixedYear, 1, 1); };

                    // Instantiate the component under test:
                    var componentUnderTest = new MyComponent();

                  // Act:
                    int year = componentUnderTest.GetTheCurrentYear();

                  // Assert:
                    // This will always be true if the component is working:
                    Assert.AreEqual(fixedYear, year);
                }
            }
    }
    ```

    ```vb
    <TestClass()> _
    Public Class TestClass1
        <TestMethod()> _
        Public Sub TestCurrentYear()
            Using s = Microsoft.QualityTools.Testing.Fakes.ShimsContext.Create()
                Dim fixedYear As Integer = 2000
                ' Arrange:
                ' Detour DateTime.Now to return a fixed date:
                System.Fakes.ShimDateTime.NowGet = _
                    Function() As DateTime
                        Return New DateTime(fixedYear, 1, 1)
                    End Function

                ' Instantiate the component under test:
                Dim componentUnderTest = New MyComponent()
                ' Act:
                Dim year As Integer = componentUnderTest.GetTheCurrentYear
                ' Assert:
                ' This will always be true if the component is working:
                Assert.AreEqual(fixedYear, year)
            End Using
        End Sub
    End Class
    ```

    填充码类名称是通过在原始类型名称前加上 `Fakes.Shim` 前缀构成的。 在方法名称后面将会追加参数名称。 （无需向 System.Fakes 添加任何程序集引用。）

前面的示例对一个静态方法使用了填充码。 若要将填充码用于实例方法，请在类型名称和方法名称之间写入 `AllInstances`：

```vb
System.IO.Fakes.ShimFile.AllInstances.ReadToEnd = ...
```

 (没有"System.IO。Fakes要引用的程序集。 命名空间由填充码创建过程生成。 但可按常规方式使用“using”或“Import”。）

你还可以为特定实例、构造函数和属性创建填充码。 有关详细信息，请参阅[使用填充码将应用与其他程序集相隔离以供单元测试使用](../test/using-shims-to-isolate-your-application-from-other-assemblies-for-unit-testing.md)。

## <a name="using-microsoft-fakes-in-the-ci"></a>在 CI 中使用 Microsoft Fakes

### <a name="microsoft-fakes-assembly-generation"></a>Microsoft Fakes 程序集生成

由于 Microsoft Fakes 需要 Visual Studio Enterprise，因此 Fakes 程序集的生成需要使用 [Visual Studio 生成任务](/azure/devops/pipelines/tasks/build/visual-studio-build?view=azure-devops&preserve-view=true)来生成项目。

::: moniker range=">=vs-2019"
> [!NOTE]
> 另一种方法是将 Fakes 程序集签入 CI，并使用 [MSBuild 任务](../msbuild/msbuild-task.md?view=vs-2019&preserve-view=true)。 这样做时，需要确保具有对测试项目中生成的Fakes程序集的程序集引用，类似于以下代码片段：

```xml
<Project Sdk="Microsoft.NET.Sdk">
    <ItemGroup>
        <Reference Include="FakesAssemblies\System.Fakes.dll"/>
    </ItemGroup>
</Project>
```

需要手动添加此引用，特别是 SDK 样式项目（A0.NET Core、.NET 5.0 和 .NET Framework) ，因为我们已移动到向测试项目隐式添加程序集引用。 如果遵循此方法，则需要确保在父程序集更改时更新 fakes 程序集。
::: moniker-end

### <a name="running-microsoft-fakes-tests"></a>运行 Microsoft Fakes 测试

只要在配置的 `FakesAssemblies` 目录（默认为 `$(ProjectDir)FakesAssemblies`）中有 Microsoft Fakes 程序集，就可以使用 [vstest 任务](/azure/devops/pipelines/tasks/test/vstest?view=azure-devops&preserve-view=true)来运行测试。

::: moniker range=">=vs-2019"
使用 Microsoft Fakes 的 [vstest](/azure/devops/pipelines/tasks/test/vstest?view=azure-devops&preserve-view=true) 任务 .NET Core 和 .NET 5.0 或更高版本项目的分布式测试Visual Studio 2019 Update 9 预览`20201020-06`版及更高版本。
::: moniker-end

::: moniker range=">=vs-2019"

## <a name="transitioning-your-net-framework-test-projects-that-use-microsoft-fakes-to-sdk-style-net-framework-net-core-or-net-50-projects-or-later-projects"></a>将使用 .NET Framework 的 Microsoft Fakes 测试项目转换为 SDK .NET Framework、.NET Core 或 .NET 5.0 项目或更高版本的项目

对于要转换到 .NET Core 或 .NET 5.0 .NET Framework，Microsoft Fakes设置最少的更改。 需要注意以下几种情况：

- 如果使用的是自定义项目模板，则需要确保它是 SDK 样式的，并针对兼容的目标框架进行生成。
- 某些类型存在于 .NET Framework 和 .NET Core/.NET 5.0 中的不同程序集（例如，`System.DateTime` 存在于 .NET Framework 中的 `System`/`mscorlib`，并存在于 .NET Core 和 .NET 5.0 中的 `System.Runtime`）。在这种情况下，需要更改正在虚设的程序集。
- 如果有对 Fakes 程序集和测试项目的程序集引用，则可能会看到有关缺少引用的生成警告，如下所示：

  ```
  (ResolveAssemblyReferences target) ->
  warning MSB3245: Could not resolve this reference. Could not locate the assembly "AssemblyName.Fakes". Check to make sure the assembly exists on disk.
  If this reference is required by your code, you may get compilation errors.
  ```
  此警告是由于在生成Fakes必要的更改，因此可以忽略。 可以通过从项目文件中删除程序集引用来避免此问题，因为我们现在是在生成过程中隐式地添加它们。
::: moniker-end

## <a name="microsoft-fakes-support"></a>Microsoft Fakes 支持 
### <a name="microsoft-fakes-in-older-projects-targeting-net-framework-non-sdk-style"></a>定目标到 .NET Framework 的旧版项目（非 SDK 样式）中的 Microsoft Fakes。
- Visual Studio Enterprise 2015 及更高版本支持 Microsoft Fakes 程序集生成。
- Microsoft Fakes 测试可以与所有可用的 Microsoft.TestPlatform NuGet 包一起运行。
- 在 Visual Studio Enterprise 2015 及更高版本中，使用 Microsoft Fakes 的测试项目支持代码覆盖率。

### <a name="microsoft-fakes-in-sdk-style-net-framework-net-core-and-net-50-or-later-projects"></a>Microsoft Fakes SDK 样式的 .NET Framework、.NET Core 和 .NET 5.0 或更高版本项目中
- Microsoft Fakes 程序集生成是在 Visual Studio Enterprise 2019 Update 6 中预览，并在 Update 8 中默认启用。
- 定目标到 .NET Framework 的项目的 Microsoft Fakes 测试可以与所有可用的 Microsoft.TestPlatform NuGet 包一起运行。
- Microsoft Fakes面向 .NET Core 和 .NET 5.0 或更高版本的项目的 Microsoft Fakes 测试可以使用 [16.9.0-preview-20210106-01](https://www.nuget.org/packages/Microsoft.TestPlatform/16.9.0-preview-20210106-01) 及更高版本的 Microsoft.TestPlatform NuGet 包运行。
- 在 Visual Studio Enterprise 2015 及更高版本中，使用 Microsoft Fakes 且定目标到 .NET Framework 的测试项目支持代码覆盖率。
- Visual Studio 2019 update 9 及更高版本中提供了对使用 Microsoft Fakes 面向 .NET Core 和 .NET 5.0 或更高版本的测试项目的代码覆盖率支持。


## <a name="in-this-section"></a>本节内容

[使用存根针对单元测试隔离应用程序的各个部分](../test/using-stubs-to-isolate-parts-of-your-application-from-each-other-for-unit-testing.md)

[使用填充码针对单元测试将应用程序与程序集隔离](../test/using-shims-to-isolate-your-application-from-other-assemblies-for-unit-testing.md)

[Microsoft Fakes 中的代码生成、编译和命名约定](../test/code-generation-compilation-and-naming-conventions-in-microsoft-fakes.md)